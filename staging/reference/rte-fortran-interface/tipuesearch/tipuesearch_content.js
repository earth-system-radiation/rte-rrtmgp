var tipuesearch = {"pages":[{"title":" RTE-Fortran ","text":"RTE-Fortran These pages provide a programmer's view of the Fortran user interface to RTE. Procedures in the two solvers ( rte_lw , rte_sw )\nrequire problems specified as sets of optical properties along with boundary conditions and/or internal sources of radiation.\nThe reduction of spectrally- and spatially-detailed calculations that specifies the output\nis defined in a flux output type The optical properties module provides a way to specify the spectrally-dependent\noptical properties of the atmosphere consistent with calculations neglecting scattering,\nusing two-stream scattering, or using n-stream scattering. init() routines to specify e.g. the spectral discretization load() routines to provide data (e.g. lookup tables) needed to do a calculation alloc() routines to allocate memory once the problem size is known finalize() routines to reset variables to an un-initialized state Some classes have get_ncol() and get_nlay() methods to report the problem size Some classes have get_subset() methods to extract values along the column dimension The listings below may not be exhaustive.\nTo see the full listings use the links at the top of the page.\nThere is a search bar in the top right. Return to the Documentation overview or the reference overview . Developer Info The RTE+RRTTMGP consortium","tags":"home","loc":"index.html"},{"title":"ty_source_func_lw – RTE-Fortran ","text":"type, public, extends( ty_optical_props ) :: ty_source_func_lw Type representing Planck source functions in computed at layer center, at layer edges using\n  spectral mapping in each direction separately, and at the surface Inherits type~~ty_source_func_lw~~InheritsGraph type~ty_source_func_lw ty_source_func_lw type~ty_optical_props ty_optical_props type~ty_source_func_lw->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lay_source lev_source sfc_source sfc_source_Jac Type-Bound Procedures alloc bands_are_equal convert_band2gpt convert_gpt2band expand finalize get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_subset gpoints_are_equal init is_allocated is_initialized set_name Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable, dimension(:,:,:) :: lay_source Planck source at layer average temperature (ncol, nlay, ngpt) real(kind=wp), public, allocatable, dimension(:,:,:) :: lev_source Planck source at layer edge (ncol, nlay+1, ngpt) real(kind=wp), public, allocatable, dimension(:,:  ) :: sfc_source Planck function at surface temperature real(kind=wp), public, allocatable, dimension(:,:  ) :: sfc_source_Jac surface source Jacobian Type-Bound Procedures generic, public :: alloc => alloc_lw, copy_and_alloc_lw private function alloc_lw(this, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) private function copy_and_alloc_lw(this, ncol, nlay, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: bands_are_equal private pure function bands_are_equal(this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt private pure function convert_band2gpt(this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,dimension(2) procedure, public :: convert_gpt2band private pure function convert_gpt2band(this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: expand private pure function expand(this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_lw private subroutine finalize_lw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: this procedure, public :: get_band_lims_gpoint private pure function get_band_lims_gpoint(this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength private pure function get_band_lims_wavelength(this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber private pure function get_band_lims_wavenumber(this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands private pure function get_gpoint_bands(this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name private function get_name(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband private pure function get_nband(this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol => get_ncol_lw private pure function get_ncol_lw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value integer procedure, public :: get_ngpt private pure function get_ngpt(this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_nlay => get_nlay_lw private pure function get_nlay_lw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value integer procedure, public :: get_subset => get_subset_range_lw private function get_subset_range_lw(full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_source_func_lw ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal private pure function gpoints_are_equal(this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical generic, public :: init => init_base, init_base_from_copy private function init_base(this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) private function init_base_from_copy(this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_allocated => is_allocated_lw private pure function is_allocated_lw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_lw ), intent(in) :: this Return Value logical procedure, public :: is_initialized => is_initialized_base private pure function is_initialized_base(this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name private subroutine set_name(this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name","tags":"","loc":"type/ty_source_func_lw.html"},{"title":"ty_source_func_sw – RTE-Fortran ","text":"type, public, extends( ty_optical_props ) :: ty_source_func_sw Inherits type~~ty_source_func_sw~~InheritsGraph type~ty_source_func_sw ty_source_func_sw type~ty_optical_props ty_optical_props type~ty_source_func_sw->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures alloc bands_are_equal convert_band2gpt convert_gpt2band expand finalize get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_subset gpoints_are_equal init is_allocated is_initialized set_name Type-Bound Procedures generic, public :: alloc => alloc_sw, copy_and_alloc_sw private function alloc_sw(this, ncol) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this integer, intent(in) :: ncol Return Value character(len=128) private function copy_and_alloc_sw(this, ncol, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this integer, intent(in) :: ncol class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: bands_are_equal private pure function bands_are_equal(this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt private pure function convert_band2gpt(this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,dimension(2) procedure, public :: convert_gpt2band private pure function convert_gpt2band(this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: expand private pure function expand(this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_sw private subroutine finalize_sw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: this procedure, public :: get_band_lims_gpoint private pure function get_band_lims_gpoint(this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength private pure function get_band_lims_wavelength(this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber private pure function get_band_lims_wavenumber(this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands private pure function get_gpoint_bands(this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name private function get_name(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband private pure function get_nband(this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol => get_ncol_sw private pure function get_ncol_sw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(in) :: this Return Value integer procedure, public :: get_ngpt private pure function get_ngpt(this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_subset => get_subset_range_sw private function get_subset_range_sw(full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_source_func_sw ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal private pure function gpoints_are_equal(this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical generic, public :: init => init_base, init_base_from_copy private function init_base(this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) private function init_base_from_copy(this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_allocated => is_allocated_sw private pure function is_allocated_sw(this) Arguments Type Intent Optional Attributes Name class( ty_source_func_sw ), intent(in) :: this Return Value logical procedure, public :: is_initialized => is_initialized_base private pure function is_initialized_base(this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name private subroutine set_name(this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name","tags":"","loc":"type/ty_source_func_sw.html"},{"title":"ty_optical_props – RTE-Fortran ","text":"type, public :: ty_optical_props Base class for optical properties Describes the spectral discretization including the wavenumber limits\n  of each band (spectral region) and the mapping between g-points and bands Inherited by type~~ty_optical_props~~InheritedByGraph type~ty_optical_props ty_optical_props type~ty_source_func_lw ty_source_func_lw type~ty_source_func_lw->type~ty_optical_props type~ty_source_func_sw ty_source_func_sw type~ty_source_func_sw->type~ty_optical_props type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props_arry->type~ty_optical_props type~ty_optical_props_1scl ty_optical_props_1scl type~ty_optical_props_1scl->type~ty_optical_props_arry type~ty_optical_props_2str ty_optical_props_2str type~ty_optical_props_2str->type~ty_optical_props_arry type~ty_optical_props_nstr ty_optical_props_nstr type~ty_optical_props_nstr->type~ty_optical_props_arry Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures bands_are_equal convert_band2gpt convert_gpt2band expand finalize get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ngpt gpoints_are_equal init is_initialized set_name Type-Bound Procedures procedure, public :: bands_are_equal private pure function bands_are_equal(this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt private pure function convert_band2gpt(this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,dimension(2) procedure, public :: convert_gpt2band private pure function convert_gpt2band(this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: expand private pure function expand(this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base private subroutine finalize_base(this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this procedure, public :: get_band_lims_gpoint private pure function get_band_lims_gpoint(this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength private pure function get_band_lims_wavelength(this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber private pure function get_band_lims_wavenumber(this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands private pure function get_gpoint_bands(this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name private function get_name(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband private pure function get_nband(this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ngpt private pure function get_ngpt(this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: gpoints_are_equal private pure function gpoints_are_equal(this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical generic, public :: init => init_base, init_base_from_copy private function init_base(this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) private function init_base_from_copy(this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base private pure function is_initialized_base(this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name private subroutine set_name(this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name","tags":"","loc":"type/ty_optical_props.html"},{"title":"ty_optical_props_1scl – RTE-Fortran ","text":"type, public, extends( ty_optical_props_arry ) :: ty_optical_props_1scl ty_optical_props_arry represents optical properties as arrays with dimensions\n      column, height, spectral point\n  - Class 1-scalar only (extinction) optical depth\n  -  Class two-stream adds arrays for single scattering albedo ssa and\n     asymmetry parameter needed in two-stream methods\n  - Class n-stream adds arrays for single scattering albedo ssa and\n     phase function moments (index 1 = g) for use with discrete ordinate methods Inherits type~~ty_optical_props_1scl~~InheritsGraph type~ty_optical_props_1scl ty_optical_props_1scl type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props_1scl->type~ty_optical_props_arry type~ty_optical_props ty_optical_props type~ty_optical_props_arry->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables tau Type-Bound Procedures alloc_1scl bands_are_equal convert_band2gpt convert_gpt2band delta_scale expand finalize finalize_1scl get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_subset gpoints_are_equal increment init is_initialized set_name set_top_at_1 top_is_at_1 validate Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_1scl => alloc_only_1scl, init_and_alloc_1scl, copy_and_alloc_1scl private function alloc_only_1scl(this, ncol, nlay) result(err_message) Straight allocation routines Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) private function init_and_alloc_1scl(this, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Initialization by specifying band limits and possibly g-point/band mapping Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) private function copy_and_alloc_1scl(this, ncol, nlay, spectral_desc, name) result(err_message) Initialization from an existing spectral discretization/ty_optical_props Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) procedure, public :: bands_are_equal private pure function bands_are_equal(this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt private pure function convert_band2gpt(this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,dimension(2) procedure, public :: convert_gpt2band private pure function convert_gpt2band(this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: delta_scale => delta_scale_1scl private function delta_scale_1scl(this, for) result(err_message) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) procedure, public :: expand private pure function expand(this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base private subroutine finalize_base(this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this procedure, public :: finalize_1scl private function finalize_1scl(this) result(err_message) Finalize routines Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ) :: this Return Value character(len=128) procedure, public :: get_band_lims_gpoint private pure function get_band_lims_gpoint(this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength private pure function get_band_lims_wavelength(this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber private pure function get_band_lims_wavenumber(this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands private pure function get_gpoint_bands(this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name private function get_name(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband private pure function get_nband(this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol private pure function get_ncol(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_ngpt private pure function get_ngpt(this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_nlay private pure function get_nlay(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_subset => subset_1scl_range private function subset_1scl_range(full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal private pure function gpoints_are_equal(this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: increment Increment another set of values private function increment(op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) generic, public :: init => init_base, init_base_from_copy private function init_base(this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) private function init_base_from_copy(this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base private pure function is_initialized_base(this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name private subroutine set_name(this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure, public :: set_top_at_1 private subroutine set_top_at_1(this, top_at_1) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: this Set vertical orientation of class - .true. if array index 1 is top of atmosphere logical, intent(in) :: top_at_1 procedure, public :: top_is_at_1 private pure function top_is_at_1(this) Routines for array classes: vertical orientation Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value logical procedure, public :: validate => validate_1scalar private function validate_1scalar(this) result(err_message) --- Validation Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_1scl ), intent(in) :: this Return Value character(len=128)","tags":"","loc":"type/ty_optical_props_1scl.html"},{"title":"ty_optical_props_2str – RTE-Fortran ","text":"type, public, extends( ty_optical_props_arry ) :: ty_optical_props_2str Inherits type~~ty_optical_props_2str~~InheritsGraph type~ty_optical_props_2str ty_optical_props_2str type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props_2str->type~ty_optical_props_arry type~ty_optical_props ty_optical_props type~ty_optical_props_arry->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables g ssa tau Type-Bound Procedures alloc_2str bands_are_equal convert_band2gpt convert_gpt2band delta_scale expand finalize finalize_2str get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_subset gpoints_are_equal increment init is_initialized set_name set_top_at_1 top_is_at_1 validate Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:), allocatable :: g asymmetry parameter (ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: ssa single-scattering albedo (ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_2str => alloc_only_2str, init_and_alloc_2str, copy_and_alloc_2str private function alloc_only_2str(this, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) private function init_and_alloc_2str(this, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) private function copy_and_alloc_2str(this, ncol, nlay, spectral_desc, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) procedure, public :: bands_are_equal private pure function bands_are_equal(this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt private pure function convert_band2gpt(this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,dimension(2) procedure, public :: convert_gpt2band private pure function convert_gpt2band(this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: delta_scale => delta_scale_2str private function delta_scale_2str(this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Forward scattering fraction; g**2 if not provided Return Value character(len=128) procedure, public :: expand private pure function expand(this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base private subroutine finalize_base(this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this procedure, public :: finalize_2str private function finalize_2str(this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ) :: this Return Value character(len=128) procedure, public :: get_band_lims_gpoint private pure function get_band_lims_gpoint(this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength private pure function get_band_lims_wavelength(this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber private pure function get_band_lims_wavenumber(this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands private pure function get_gpoint_bands(this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name private function get_name(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband private pure function get_nband(this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol private pure function get_ncol(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_ngpt private pure function get_ngpt(this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_nlay private pure function get_nlay(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_subset => subset_2str_range private function subset_2str_range(full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal private pure function gpoints_are_equal(this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: increment Increment another set of values private function increment(op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) generic, public :: init => init_base, init_base_from_copy private function init_base(this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) private function init_base_from_copy(this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base private pure function is_initialized_base(this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name private subroutine set_name(this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure, public :: set_top_at_1 private subroutine set_top_at_1(this, top_at_1) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: this Set vertical orientation of class - .true. if array index 1 is top of atmosphere logical, intent(in) :: top_at_1 procedure, public :: top_is_at_1 private pure function top_is_at_1(this) Routines for array classes: vertical orientation Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value logical procedure, public :: validate => validate_2stream private function validate_2stream(this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_2str ), intent(in) :: this Return Value character(len=128)","tags":"","loc":"type/ty_optical_props_2str.html"},{"title":"ty_optical_props_arry – RTE-Fortran ","text":"type, public, abstract, extends( ty_optical_props ) :: ty_optical_props_arry Optical properties as arrays, normally dimensioned ncol, nlay, ngpt/nbnd The abstract base class for arrays defines what procedures will be available Inherits type~~ty_optical_props_arry~~InheritsGraph type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props ty_optical_props type~ty_optical_props_arry->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~ty_optical_props_arry~~InheritedByGraph type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props_1scl ty_optical_props_1scl type~ty_optical_props_1scl->type~ty_optical_props_arry type~ty_optical_props_2str ty_optical_props_2str type~ty_optical_props_2str->type~ty_optical_props_arry type~ty_optical_props_nstr ty_optical_props_nstr type~ty_optical_props_nstr->type~ty_optical_props_arry Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables tau Type-Bound Procedures bands_are_equal convert_band2gpt convert_gpt2band delta_scale expand finalize get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_subset gpoints_are_equal increment init is_initialized set_name set_top_at_1 top_is_at_1 validate Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures procedure, public :: bands_are_equal private pure function bands_are_equal(this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt private pure function convert_band2gpt(this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,dimension(2) procedure, public :: convert_gpt2band private pure function convert_gpt2band(this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure(delta_scale_abstract), public, deferred :: delta_scale function delta_scale_abstract(this, for) result(err_message) Prototype Delta-scaling Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) Forward scattering fraction; g**2 if not provided procedure, public :: expand private pure function expand(this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base private subroutine finalize_base(this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this procedure, public :: get_band_lims_gpoint private pure function get_band_lims_gpoint(this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength private pure function get_band_lims_wavelength(this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber private pure function get_band_lims_wavenumber(this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands private pure function get_gpoint_bands(this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name private function get_name(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband private pure function get_nband(this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol private pure function get_ncol(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_ngpt private pure function get_ngpt(this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_nlay private pure function get_nlay(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure(subset_range_abstract), public, deferred :: get_subset function subset_range_abstract(full, start, n, subset) result(err_message) Prototype Subsetting -- currently there are only routines with start col and count Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal private pure function gpoints_are_equal(this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: increment Increment another set of values private function increment(op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) generic, public :: init => init_base, init_base_from_copy private function init_base(this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) private function init_base_from_copy(this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base private pure function is_initialized_base(this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name private subroutine set_name(this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure, public :: set_top_at_1 private subroutine set_top_at_1(this, top_at_1) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: this Set vertical orientation of class - .true. if array index 1 is top of atmosphere logical, intent(in) :: top_at_1 procedure, public :: top_is_at_1 private pure function top_is_at_1(this) Routines for array classes: vertical orientation Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value logical procedure(validate_abstract), public, deferred :: validate Deferred procedures -- each must be implemented in each child class with\n  arguments following the abstract interface (defined below) function validate_abstract(this) result(err_message) Prototype Validation function looks only at internal data Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value character(len=128)","tags":"","loc":"type/ty_optical_props_arry.html"},{"title":"ty_optical_props_nstr – RTE-Fortran ","text":"type, public, extends( ty_optical_props_arry ) :: ty_optical_props_nstr Inherits type~~ty_optical_props_nstr~~InheritsGraph type~ty_optical_props_nstr ty_optical_props_nstr type~ty_optical_props_arry ty_optical_props_arry type~ty_optical_props_nstr->type~ty_optical_props_arry type~ty_optical_props ty_optical_props type~ty_optical_props_arry->type~ty_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables p ssa tau Type-Bound Procedures alloc_nstr bands_are_equal convert_band2gpt convert_gpt2band delta_scale expand finalize finalize_nstr get_band_lims_gpoint get_band_lims_wavelength get_band_lims_wavenumber get_gpoint_bands get_name get_nband get_ncol get_ngpt get_nlay get_nmom get_subset gpoints_are_equal increment init is_initialized set_name set_top_at_1 top_is_at_1 validate Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:,:), allocatable :: p phase-function moments (nmom, ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: ssa single-scattering albedo (ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_nstr => alloc_only_nstr, init_and_alloc_nstr, copy_and_alloc_nstr private function alloc_only_nstr(this, nmom, ncol, nlay) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay Return Value character(len=128) private function init_and_alloc_nstr(this, nmom, ncol, nlay, band_lims_wvn, band_lims_gpt, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) private function copy_and_alloc_nstr(this, nmom, ncol, nlay, spectral_desc, name) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this integer, intent(in) :: nmom integer, intent(in) :: ncol integer, intent(in) :: nlay class( ty_optical_props ), intent(in) :: spectral_desc character(len=*), intent(in), optional :: name Return Value character(len=128) procedure, public :: bands_are_equal private pure function bands_are_equal(this, that) Are the bands of two objects the same? (same number, same wavelength limits) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: convert_band2gpt private pure function convert_band2gpt(this, band) First and last g-point of a specific band Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: band Return Value integer,dimension(2) procedure, public :: convert_gpt2band private pure function convert_gpt2band(this, gpt) Band associated with a specific g-point Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this integer, intent(in) :: gpt Return Value integer procedure, public :: delta_scale => delta_scale_nstr private function delta_scale_nstr(this, for) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(inout) :: this real(kind=wp), intent(in), optional dimension(:,:,:) :: for Return Value character(len=128) procedure, public :: expand private pure function expand(this, arr_in) result(arr_out) Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this real(kind=wp), intent(in), dimension(:) :: arr_in Return Value real(kind=wp),dimension(size(this%gpt2band)) procedure, public :: finalize => finalize_base private subroutine finalize_base(this) Base class: finalize (deallocate memory) Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this procedure, public :: finalize_nstr private function finalize_nstr(this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ) :: this Return Value character(len=128) procedure, public :: get_band_lims_gpoint private pure function get_band_lims_gpoint(this) The first and last g-point of all bands at once\n dimension (2, nbands) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) procedure, public :: get_band_lims_wavelength private pure function get_band_lims_wavelength(this) Lower and upper wavelength of all bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_band_lims_wavenumber private pure function get_band_lims_wavenumber(this) Lower and upper wavenumber of all bands\n (upper and lower wavenumber by band) = band_lims_wvn(2,band) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value real(kind=wp),dimension(size(this%band_lims_wvn,1), size(this%band_lims_wvn,2)) procedure, public :: get_gpoint_bands private pure function get_gpoint_bands(this) Bands for all the g-points at once\n dimension (ngpt) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer,dimension(size(this%gpt2band,dim=1)) procedure, public :: get_name private function get_name(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value character(len=name_len) procedure, public :: get_nband private pure function get_nband(this) Number of bands Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_ncol private pure function get_ncol(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_ngpt private pure function get_ngpt(this) Number of g-points Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value integer procedure, public :: get_nlay private pure function get_nlay(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value integer procedure, public :: get_nmom private pure function get_nmom(this) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(in) :: this Return Value integer procedure, public :: get_subset => subset_nstr_range private function subset_nstr_range(full, start, n, subset) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(inout) :: full integer, intent(in) :: start integer, intent(in) :: n class( ty_optical_props_arry ), intent(inout) :: subset Return Value character(len=128) procedure, public :: gpoints_are_equal private pure function gpoints_are_equal(this, that) Is the g-point structure of two objects the same?\n   (same bands, same number of g-points, same mapping between bands and g-points) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this class( ty_optical_props ), intent(in) :: that Return Value logical procedure, public :: increment Increment another set of values private function increment(op_in, op_io) result(err_message) Routines for array classes: incrementing\n  a%increment(b) adds the values of a to b, changing b and leaving a untouched Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: op_in class( ty_optical_props_arry ), intent(inout) :: op_io Return Value character(len=128) generic, public :: init => init_base, init_base_from_copy private function init_base(this, band_lims_wvn, band_lims_gpt, name) result(err_message) Base class: Initialization\n  Values are assumed to be defined in bands a mapping between bands and g-points is provided Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:) :: band_lims_wvn integer, intent(in), optional dimension(:,:) :: band_lims_gpt character(len=*), intent(in), optional :: name Return Value character(len=128) private function init_base_from_copy(this, spectral_desc) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this class( ty_optical_props ), intent(in) :: spectral_desc Return Value character(len=128) procedure, public :: is_initialized => is_initialized_base private pure function is_initialized_base(this) Base class: return true if initialized, false otherwise Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(in) :: this Return Value logical procedure, public :: set_name private subroutine set_name(this, name) --- Setting/getting the name Read more… Arguments Type Intent Optional Attributes Name class( ty_optical_props ), intent(inout) :: this character(len=*), intent(in) :: name procedure, public :: set_top_at_1 private subroutine set_top_at_1(this, top_at_1) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(inout) :: this Set vertical orientation of class - .true. if array index 1 is top of atmosphere logical, intent(in) :: top_at_1 procedure, public :: top_is_at_1 private pure function top_is_at_1(this) Routines for array classes: vertical orientation Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: this Return Value logical procedure, public :: validate => validate_nstream private function validate_nstream(this) result(err_message) Arguments Type Intent Optional Attributes Name class( ty_optical_props_nstr ), intent(in) :: this Return Value character(len=128)","tags":"","loc":"type/ty_optical_props_nstr.html"},{"title":"ty_fluxes – RTE-Fortran ","text":"type, public, abstract :: ty_fluxes Abstract base class: reduce() function accepts spectral flux profiles, computes desired outputs are_desired() returns a logical Inherited by type~~ty_fluxes~~InheritedByGraph type~ty_fluxes ty_fluxes type~ty_fluxes_broadband ty_fluxes_broadband type~ty_fluxes_broadband->type~ty_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures are_desired reduce Type-Bound Procedures procedure(are_desired_abstract), public, deferred :: are_desired function are_desired_abstract(this) Prototype Arguments Type Intent Optional Attributes Name class( ty_fluxes ), intent(in) :: this Return Value logical procedure(reduce_abstract), public, deferred :: reduce function reduce_abstract(this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Prototype This routine takes the fully resolved calculation (detailed in spectral and vertical dimensions) and\n  computes desired outputs. Output values will normally be data components of the derived type. Arguments Type Intent Optional Attributes Name class( ty_fluxes ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128)","tags":"","loc":"type/ty_fluxes.html"},{"title":"ty_fluxes_broadband – RTE-Fortran ","text":"type, public, extends( ty_fluxes ) :: ty_fluxes_broadband Class implementing broadband integration for the complete flux profile.\n  Data components are pointers so results can be written directly into memory Inherits type~~ty_fluxes_broadband~~InheritsGraph type~ty_fluxes_broadband ty_fluxes_broadband type~ty_fluxes ty_fluxes type~ty_fluxes_broadband->type~ty_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables flux_dn flux_dn_dir flux_net flux_up Type-Bound Procedures are_desired reduce Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:), pointer :: flux_dn => NULL() real(kind=wp), public, dimension(:,:), pointer :: flux_dn_dir => NULL() real(kind=wp), public, dimension(:,:), pointer :: flux_net => NULL() real(kind=wp), public, dimension(:,:), pointer :: flux_up => NULL() Type-Bound Procedures procedure, public :: are_desired => are_desired_broadband private function are_desired_broadband(this) Are any fluxes desired from this set of g-point fluxes? We can tell because memory will\n  be allocated for output Arguments Type Intent Optional Attributes Name class( ty_fluxes_broadband ), intent(in) :: this Return Value logical procedure, public :: reduce => reduce_broadband private function reduce_broadband(this, gpt_flux_up, gpt_flux_dn, spectral_disc, top_at_1, gpt_flux_dn_dir) result(error_msg) Broadband fluxes -- simply sum over the spectral dimension and report the whole profile Arguments Type Intent Optional Attributes Name class( ty_fluxes_broadband ), intent(inout) :: this real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_up real(kind=wp), intent(in), dimension(:,:,:) :: gpt_flux_dn class( ty_optical_props ), intent(in) :: spectral_disc logical, intent(in) :: top_at_1 real(kind=wp), intent(in), optional dimension(:,:,:) :: gpt_flux_dn_dir Return Value character(len=128)","tags":"","loc":"type/ty_fluxes_broadband.html"},{"title":"rte_lw – RTE-Fortran","text":"public function rte_lw(optical_props, sources, sfc_emis, fluxes, inc_flux, n_gauss_angles, use_2stream, lw_Ds, flux_up_Jac) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: optical_props Set of optical properties as one or more arrays type( ty_source_func_lw ), intent(in) :: sources Derived type with Planck source functions real(kind=wp), intent(in), dimension(:,:) :: sfc_emis emissivity at surface [] (nband, ncol) class( ty_fluxes ), intent(inout) :: fluxes Dervied type for computing spectral integrals from g-point fluxes.\nDefault computes broadband fluxes at all levels if output arrays are defined. Can be extended per user desires. real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux incident flux at domain top [W/m2] (ncol, ngpts) integer, intent(in), optional :: n_gauss_angles Number of angles used in Gaussian quadrature (max 3, no-scattering solution) logical, intent(in), optional :: use_2stream When 2-stream parameters (tau/ssa/g) are provided, use 2-stream methods\nDefault is to use re-scaled longwave transport real(kind=wp), intent(in), optional dimension(:,:) :: lw_Ds User-specifed 1/cos of transport angle per col, g-point real(kind=wp), intent(inout), optional dimension(:,:), target :: flux_up_Jac surface temperature flux  Jacobian [W/m2/K] (ncol, nlay+1) Return Value character(len=128) If empty, calculation was successful Calls proc~~rte_lw~~CallsGraph proc~rte_lw rte_lw interface~any_vals_less_than any_vals_less_than proc~rte_lw->interface~any_vals_less_than interface~any_vals_outside any_vals_outside proc~rte_lw->interface~any_vals_outside zero_array zero_array proc~rte_lw->zero_array interface~extents_are extents_are proc~rte_lw->interface~extents_are lw_solver_noscat lw_solver_noscat proc~rte_lw->lw_solver_noscat lw_solver_2stream lw_solver_2stream proc~rte_lw->lw_solver_2stream Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rte_lw.html"},{"title":"any_vals_less_than – RTE-Fortran","text":"public interface any_vals_less_than Values less than a floor (including masked versions) Called by interface~~any_vals_less_than~~CalledByGraph interface~any_vals_less_than any_vals_less_than proc~rte_lw rte_lw proc~rte_lw->interface~any_vals_less_than Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures any_vals_less_than_1D any_vals_less_than_2D any_vals_less_than_3D any_vals_less_than_1D_masked any_vals_less_than_2D_masked any_vals_less_than_3D_masked Module Procedures private function any_vals_less_than_1D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_2D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_3D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_1D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array logical(kind=wl), intent(in), dimension(:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_2D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array logical(kind=wl), intent(in), dimension(:,:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_3D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array logical(kind=wl), intent(in), dimension(:,:,:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical","tags":"","loc":"interface/any_vals_less_than.html"},{"title":"any_vals_outside – RTE-Fortran","text":"public interface any_vals_outside Values outside a range (including masked versions) Called by interface~~any_vals_outside~~CalledByGraph interface~any_vals_outside any_vals_outside proc~rte_lw rte_lw proc~rte_lw->interface~any_vals_outside Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures any_vals_outside_1D any_vals_outside_2D any_vals_outside_3D any_vals_outside_1D_masked any_vals_outside_2D_masked any_vals_outside_3D_masked Module Procedures private function any_vals_outside_1D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_2D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_3D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_1D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array logical(kind=wl), intent(in), dimension(:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_2D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array logical(kind=wl), intent(in), dimension(:,:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_3D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array logical(kind=wl), intent(in), dimension(:,:,:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical","tags":"","loc":"interface/any_vals_outside.html"},{"title":"extents_are – RTE-Fortran","text":"public interface extents_are Find the extents of an array Called by interface~~extents_are~~CalledByGraph interface~extents_are extents_are proc~rte_lw rte_lw proc~rte_lw->interface~extents_are Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures extents_are_1D extents_are_2D extents_are_3D extents_are_4D extents_are_5D extents_are_6D extents_are_2d_int Module Procedures private function extents_are_1d(array, n1) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:          ) :: array integer, intent(in) :: n1 Return Value logical(kind=wl) private function extents_are_2d(array, n1, n2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:        ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 Return Value logical(kind=wl) private function extents_are_3d(array, n1, n2, n3) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:      ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 Return Value logical(kind=wl) private function extents_are_4d(array, n1, n2, n3, n4) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:    ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 Return Value logical(kind=wl) private function extents_are_5d(array, n1, n2, n3, n4, n5) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:,:  ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 integer, intent(in) :: n5 Return Value logical(kind=wl) private function extents_are_6d(array, n1, n2, n3, n4, n5, n6) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 integer, intent(in) :: n5 integer, intent(in) :: n6 Return Value logical(kind=wl) private function extents_are_2d_int(array, n1, n2) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:        ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 Return Value logical(kind=wl)","tags":"","loc":"interface/extents_are.html"},{"title":"rte_config_checks – RTE-Fortran","text":"public interface rte_config_checks Specify checking of extents and values individually, or all checks together Contents Module Procedures rte_config_checks_each rte_config_checks_all Module Procedures private subroutine rte_config_checks_each(extents, values) Do extents and/or values checks within RTE+RRTMGP Fortran classes Arguments Type Intent Optional Attributes Name logical(kind=wl), intent(in) :: extents logical(kind=wl), intent(in) :: values private subroutine rte_config_checks_all(do_checks) Do all checks within RTE+RRTMGP Fortran classes Arguments Type Intent Optional Attributes Name logical(kind=wl), intent(in) :: do_checks","tags":"","loc":"interface/rte_config_checks.html"},{"title":"rte_sw – RTE-Fortran","text":"public interface rte_sw Contents Module Procedures rte_sw_mu0_bycol rte_sw_mu0_full Module Procedures private function rte_sw_mu0_bycol(atmos, mu0, inc_flux, sfc_alb_dir, sfc_alb_dif, fluxes, inc_flux_dif) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: atmos Optical properties provided as arrays real(kind=wp), intent(in), dimension(:) :: mu0 cosine of solar zenith angle (ncol) - will be assumed constant with height real(kind=wp), intent(in), dimension(:,:) :: inc_flux incident flux at top of domain [W/m2] (ncol, ngpt) real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dir surface albedo for direct and real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dif diffuse radiation (nband, ncol) class( ty_fluxes ), intent(inout) :: fluxes Class describing output calculations real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux_dif incident diffuse flux at top of domain [W/m2] (ncol, ngpt) Return Value character(len=128) If empty, calculation was successful private function rte_sw_mu0_full(atmos, mu0, inc_flux, sfc_alb_dir, sfc_alb_dif, fluxes, inc_flux_dif) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: atmos Optical properties provided as arrays real(kind=wp), intent(in), dimension(:,:) :: mu0 cosine of solar zenith angle (ncol, nlay) real(kind=wp), intent(in), dimension(:,:) :: inc_flux incident flux at top of domain [W/m2] (ncol, ngpt) real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dir surface albedo for direct and real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dif diffuse radiation (nband, ncol) class( ty_fluxes ), intent(inout) :: fluxes Class describing output calculations real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux_dif incident diffuse flux at top of domain [W/m2] (ncol, ngpt) Return Value character(len=128) If empty, calculation was successful","tags":"","loc":"interface/rte_sw.html"},{"title":"mo_rte_lw – RTE-Fortran","text":"Compute longwave radiative fluxes Contains a single routine to compute direct and diffuse fluxes of solar radiation given atmospheric optical properties, spectrally-resolved via one of the sub-classes of ty_optical_props_arry in module mo_optical_props information about vertical ordering internal Planck source functions, defined per g-point on the same spectral grid at the atmosphere,\n    via ty_source_func_lw in module mo_source_functions boundary conditions: surface emissivity defined per band optionally, a boundary condition for incident diffuse radiation optionally, an integer number of angles at which to do Gaussian quadrature if scattering is neglected If optical properties are supplied via class ty_optical_props_1scl (absorption optical thickenss only)\n   ( ty_optical_props_1scl in module mo_optical_props )\n   then an emission/absorption solver is called.\n   If optical properties are supplied via class ty_optical_props_2str\n   ( ty_optical_props_2str in module mo_optical_props )\n   fluxes are computed via a rescaling by default or, optionally, using two-stream calculations and adding. Users must ensure that emissivity is on the same spectral grid as the optical properties. Final output is via user-extensible ty_fluxes\n( ty_fluxes in module mo_fluxes )\nwhich must reduce the detailed spectral fluxes to whatever summary the user needs\nThe routine does error checking and choses which lower-level kernel to invoke based on\n  what kinds of optical properties are supplied Uses mo_source_functions mo_optical_props mo_fluxes mo_rte_util_array_validation mo_rte_util_array mo_rte_solver_kernels mo_rte_config mo_rte_kind module~~mo_rte_lw~~UsesGraph module~mo_rte_lw mo_rte_lw module~mo_source_functions mo_source_functions module~mo_rte_lw->module~mo_source_functions module~mo_fluxes mo_fluxes module~mo_rte_lw->module~mo_fluxes mo_rte_util_array mo_rte_util_array module~mo_rte_lw->mo_rte_util_array module~mo_rte_util_array_validation mo_rte_util_array_validation module~mo_rte_lw->module~mo_rte_util_array_validation module~mo_optical_props mo_optical_props module~mo_rte_lw->module~mo_optical_props mo_rte_solver_kernels mo_rte_solver_kernels module~mo_rte_lw->mo_rte_solver_kernels module~mo_rte_config mo_rte_config module~mo_rte_lw->module~mo_rte_config mo_rte_kind mo_rte_kind module~mo_rte_lw->mo_rte_kind module~mo_source_functions->module~mo_optical_props module~mo_source_functions->mo_rte_kind module~mo_fluxes->module~mo_rte_util_array_validation module~mo_fluxes->module~mo_optical_props module~mo_fluxes->module~mo_rte_config module~mo_fluxes->mo_rte_kind mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->mo_fluxes_broadband_kernels module~mo_rte_util_array_validation->mo_rte_kind module~mo_optical_props->module~mo_rte_util_array_validation module~mo_optical_props->module~mo_rte_config module~mo_optical_props->mo_rte_kind mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_rte_config->mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions rte_lw Functions public function rte_lw (optical_props, sources, sfc_emis, fluxes, inc_flux, n_gauss_angles, use_2stream, lw_Ds, flux_up_Jac) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: optical_props Set of optical properties as one or more arrays type( ty_source_func_lw ), intent(in) :: sources Derived type with Planck source functions real(kind=wp), intent(in), dimension(:,:) :: sfc_emis emissivity at surface [] (nband, ncol) class( ty_fluxes ), intent(inout) :: fluxes Dervied type for computing spectral integrals from g-point fluxes.\nDefault computes broadband fluxes at all levels if output arrays are defined. Can be extended per user desires. real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux incident flux at domain top [W/m2] (ncol, ngpts) integer, intent(in), optional :: n_gauss_angles Number of angles used in Gaussian quadrature (max 3, no-scattering solution) logical, intent(in), optional :: use_2stream When 2-stream parameters (tau/ssa/g) are provided, use 2-stream methods\nDefault is to use re-scaled longwave transport real(kind=wp), intent(in), optional dimension(:,:) :: lw_Ds User-specifed 1/cos of transport angle per col, g-point real(kind=wp), intent(inout), optional dimension(:,:), target :: flux_up_Jac surface temperature flux  Jacobian [W/m2/K] (ncol, nlay+1) Return Value character(len=128) If empty, calculation was successful","tags":"","loc":"module/mo_rte_lw.html"},{"title":"mo_rte_util_array_validation – RTE-Fortran","text":"Provide utilites for sanitizing input arrays: Uses mo_rte_kind module~~mo_rte_util_array_validation~~UsesGraph module~mo_rte_util_array_validation mo_rte_util_array_validation mo_rte_kind mo_rte_kind module~mo_rte_util_array_validation->mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rte_util_array_validation~~UsedByGraph module~mo_rte_util_array_validation mo_rte_util_array_validation module~mo_optical_props mo_optical_props module~mo_optical_props->module~mo_rte_util_array_validation module~mo_fluxes mo_fluxes module~mo_fluxes->module~mo_rte_util_array_validation module~mo_fluxes->module~mo_optical_props module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_rte_util_array_validation module~mo_rte_lw->module~mo_optical_props module~mo_rte_lw->module~mo_fluxes module~mo_source_functions mo_source_functions module~mo_rte_lw->module~mo_source_functions module~mo_rte_sw mo_rte_sw module~mo_rte_sw->module~mo_rte_util_array_validation module~mo_rte_sw->module~mo_optical_props module~mo_rte_sw->module~mo_fluxes module~mo_source_functions->module~mo_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces any_vals_less_than any_vals_outside extents_are Interfaces public interface any_vals_less_than Values less than a floor (including masked versions) private function any_vals_less_than_1D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_2D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_3D(array, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_1D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array logical(kind=wl), intent(in), dimension(:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_2D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array logical(kind=wl), intent(in), dimension(:,:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical private function any_vals_less_than_3D_masked(array, mask, check_value) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array logical(kind=wl), intent(in), dimension(:,:,:) :: mask real(kind=wp), intent(in) :: check_value Return Value logical public interface any_vals_outside Values outside a range (including masked versions) private function any_vals_outside_1D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_2D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_3D(array, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_1D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: array logical(kind=wl), intent(in), dimension(:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_2D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: array logical(kind=wl), intent(in), dimension(:,:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical private function any_vals_outside_3D_masked(array, mask, checkMin, checkMax) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: array logical(kind=wl), intent(in), dimension(:,:,:) :: mask real(kind=wp), intent(in) :: checkMin real(kind=wp), intent(in) :: checkMax Return Value logical public interface extents_are Find the extents of an array private function extents_are_1d(array, n1) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:          ) :: array integer, intent(in) :: n1 Return Value logical(kind=wl) private function extents_are_2d(array, n1, n2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:        ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 Return Value logical(kind=wl) private function extents_are_3d(array, n1, n2, n3) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:      ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 Return Value logical(kind=wl) private function extents_are_4d(array, n1, n2, n3, n4) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:    ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 Return Value logical(kind=wl) private function extents_are_5d(array, n1, n2, n3, n4, n5) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:,:  ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 integer, intent(in) :: n5 Return Value logical(kind=wl) private function extents_are_6d(array, n1, n2, n3, n4, n5, n6) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:,:,:,:) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 integer, intent(in) :: n5 integer, intent(in) :: n6 Return Value logical(kind=wl) private function extents_are_2d_int(array, n1, n2) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:        ) :: array integer, intent(in) :: n1 integer, intent(in) :: n2 Return Value logical(kind=wl)","tags":"","loc":"module/mo_rte_util_array_validation.html"},{"title":"mo_rte_config – RTE-Fortran","text":"Control input sanitization in Fortan front-end Provides public access to two proteced module variables Uses mo_rte_kind module~~mo_rte_config~~UsesGraph module~mo_rte_config mo_rte_config mo_rte_kind mo_rte_kind module~mo_rte_config->mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_rte_config~~UsedByGraph module~mo_rte_config mo_rte_config module~mo_optical_props mo_optical_props module~mo_optical_props->module~mo_rte_config module~mo_fluxes mo_fluxes module~mo_fluxes->module~mo_rte_config module~mo_fluxes->module~mo_optical_props module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_rte_config module~mo_rte_lw->module~mo_optical_props module~mo_rte_lw->module~mo_fluxes module~mo_source_functions mo_source_functions module~mo_rte_lw->module~mo_source_functions module~mo_rte_sw mo_rte_sw module~mo_rte_sw->module~mo_rte_config module~mo_rte_sw->module~mo_optical_props module~mo_rte_sw->module~mo_fluxes module~mo_source_functions->module~mo_optical_props Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables check_extents check_values Interfaces rte_config_checks Variables Type Visibility Attributes Name Initial logical(kind=wl), public :: check_extents = .true. logical(kind=wl), public :: check_values = .true. Interfaces public interface rte_config_checks Specify checking of extents and values individually, or all checks together private subroutine rte_config_checks_each(extents, values) Do extents and/or values checks within RTE+RRTMGP Fortran classes Arguments Type Intent Optional Attributes Name logical(kind=wl), intent(in) :: extents logical(kind=wl), intent(in) :: values private subroutine rte_config_checks_all(do_checks) Do all checks within RTE+RRTMGP Fortran classes Arguments Type Intent Optional Attributes Name logical(kind=wl), intent(in) :: do_checks","tags":"","loc":"module/mo_rte_config.html"},{"title":"mo_rte_sw – RTE-Fortran","text":"Compute shortwave radiative fluxes\n Contains a single routine to compute direct and diffuse fluxes of solar radiation given atmospheric optical properties on a spectral grid information about vertical ordering boundary conditions solar zenith angle, spectrally-resolved incident colimated flux, surface albedos for direct and diffuse radiation optionally, a boundary condition for incident diffuse radiation It is the user's responsibility to ensure that boundary conditions (incident fluxes, surface albedos) are on the same\n  spectral grid as the optical properties. Final output is via user-extensible ty_fluxes\n( ty_fluxes in module mo_fluxes )\nwhich must reduce the detailed spectral fluxes to whatever summary the user needs The routine does error checking and choses which lower-level kernel to invoke based on\n  what kinds of optical properties are supplied Uses mo_optical_props mo_fluxes mo_rte_util_array_validation mo_rte_util_array mo_rte_solver_kernels mo_rte_config mo_rte_kind module~~mo_rte_sw~~UsesGraph module~mo_rte_sw mo_rte_sw module~mo_optical_props mo_optical_props module~mo_rte_sw->module~mo_optical_props mo_rte_solver_kernels mo_rte_solver_kernels module~mo_rte_sw->mo_rte_solver_kernels module~mo_fluxes mo_fluxes module~mo_rte_sw->module~mo_fluxes mo_rte_util_array mo_rte_util_array module~mo_rte_sw->mo_rte_util_array module~mo_rte_util_array_validation mo_rte_util_array_validation module~mo_rte_sw->module~mo_rte_util_array_validation module~mo_rte_config mo_rte_config module~mo_rte_sw->module~mo_rte_config mo_rte_kind mo_rte_kind module~mo_rte_sw->mo_rte_kind module~mo_optical_props->module~mo_rte_util_array_validation module~mo_optical_props->module~mo_rte_config module~mo_optical_props->mo_rte_kind mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_fluxes->module~mo_optical_props module~mo_fluxes->module~mo_rte_util_array_validation module~mo_fluxes->module~mo_rte_config module~mo_fluxes->mo_rte_kind mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->mo_fluxes_broadband_kernels module~mo_rte_util_array_validation->mo_rte_kind module~mo_rte_config->mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces rte_sw Interfaces public interface rte_sw private function rte_sw_mu0_bycol(atmos, mu0, inc_flux, sfc_alb_dir, sfc_alb_dif, fluxes, inc_flux_dif) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: atmos Optical properties provided as arrays real(kind=wp), intent(in), dimension(:) :: mu0 cosine of solar zenith angle (ncol) - will be assumed constant with height real(kind=wp), intent(in), dimension(:,:) :: inc_flux incident flux at top of domain [W/m2] (ncol, ngpt) real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dir surface albedo for direct and real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dif diffuse radiation (nband, ncol) class( ty_fluxes ), intent(inout) :: fluxes Class describing output calculations real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux_dif incident diffuse flux at top of domain [W/m2] (ncol, ngpt) Return Value character(len=128) If empty, calculation was successful private function rte_sw_mu0_full(atmos, mu0, inc_flux, sfc_alb_dir, sfc_alb_dif, fluxes, inc_flux_dif) result(error_msg) Arguments Type Intent Optional Attributes Name class( ty_optical_props_arry ), intent(in) :: atmos Optical properties provided as arrays real(kind=wp), intent(in), dimension(:,:) :: mu0 cosine of solar zenith angle (ncol, nlay) real(kind=wp), intent(in), dimension(:,:) :: inc_flux incident flux at top of domain [W/m2] (ncol, ngpt) real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dir surface albedo for direct and real(kind=wp), intent(in), dimension(:,:) :: sfc_alb_dif diffuse radiation (nband, ncol) class( ty_fluxes ), intent(inout) :: fluxes Class describing output calculations real(kind=wp), intent(in), optional dimension(:,:), target :: inc_flux_dif incident diffuse flux at top of domain [W/m2] (ncol, ngpt) Return Value character(len=128) If empty, calculation was successful","tags":"","loc":"module/mo_rte_sw.html"},{"title":"mo_source_functions – RTE-Fortran","text":"Encapsulate source function arrays for longwave/lw/internal sources Uses mo_rte_kind mo_optical_props module~~mo_source_functions~~UsesGraph module~mo_source_functions mo_source_functions mo_rte_kind mo_rte_kind module~mo_source_functions->mo_rte_kind module~mo_optical_props mo_optical_props module~mo_source_functions->module~mo_optical_props module~mo_optical_props->mo_rte_kind module~mo_rte_config mo_rte_config module~mo_optical_props->module~mo_rte_config mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_rte_util_array_validation mo_rte_util_array_validation module~mo_optical_props->module~mo_rte_util_array_validation module~mo_rte_config->mo_rte_kind module~mo_rte_util_array_validation->mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_source_functions~~UsedByGraph module~mo_source_functions mo_source_functions module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_source_functions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types ty_source_func_lw ty_source_func_sw Derived Types type, public, extends( ty_optical_props ) :: ty_source_func_lw Type representing Planck source functions in computed at layer center, at layer edges using\n  spectral mapping in each direction separately, and at the surface Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable, dimension(:,:,:) :: lay_source Planck source at layer average temperature (ncol, nlay, ngpt) real(kind=wp), public, allocatable, dimension(:,:,:) :: lev_source Planck source at layer edge (ncol, nlay+1, ngpt) real(kind=wp), public, allocatable, dimension(:,:  ) :: sfc_source Planck function at surface temperature real(kind=wp), public, allocatable, dimension(:,:  ) :: sfc_source_Jac surface source Jacobian Type-Bound Procedures generic, public :: alloc => alloc_lw, copy_and_alloc_lw procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: expand procedure, public :: finalize => finalize_lw procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol => get_ncol_lw procedure, public :: get_ngpt procedure, public :: get_nlay => get_nlay_lw procedure, public :: get_subset => get_subset_range_lw procedure, public :: gpoints_are_equal generic, public :: init => init_base, init_base_from_copy procedure, public :: is_allocated => is_allocated_lw procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name type, public, extends( ty_optical_props ) :: ty_source_func_sw Type-Bound Procedures generic, public :: alloc => alloc_sw, copy_and_alloc_sw procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: expand procedure, public :: finalize => finalize_sw procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol => get_ncol_sw procedure, public :: get_ngpt procedure, public :: get_subset => get_subset_range_sw procedure, public :: gpoints_are_equal generic, public :: init => init_base, init_base_from_copy procedure, public :: is_allocated => is_allocated_sw procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name","tags":"","loc":"module/mo_source_functions.html"},{"title":"mo_optical_props – RTE-Fortran","text":"Encapsulate optical properties defined on a spectral grid of N bands. The bands are described by their limiting wavenumbers. They need not be contiguous or complete.\n  A band may contain more than one spectral sub-point (g-point) in which case a mapping must be supplied.\n  A name may be provided and will be prepended to error messages.\n  The base class (ty_optical_props) encapsulates only this spectral discretization and must be initialized\n     with the spectral information before use. Optical properties may be represented as arrays with dimensions ncol, nlay, ngpt\n  (abstract class ty_optical_props_arry).\n  The type holds arrays depending on how much information is needed\n  There are three possibilites ty_optical_props_1scl holds absorption optical depth tau, used in calculations accounting for extinction and emission ty_optical_props_2str holds extincion optical depth tau, single-scattering albedo ssa, and\n       asymmetry parameter g. These fields are what's needed for two-stream calculations. ty_optical_props_nstr holds extincion optical depth tau, single-scattering albedo ssa, and\n       phase function moments p with leading dimension nmom. These fields are what's needed for multi-stream calculations. These classes must be allocated before use. Initialization and allocation can be combined.\n  The classes have a validate() function that checks all arrays for valid values (e.g. tau > 0.)\n  The vertical orientation can be specified via this%set_top_at_1() or obtained via this%top_at_1(). Optical properties can be delta-scaled (though this is currently implemented only for two-stream arrays) Optical properties can increment or \"add themselves to\" a set of properties represented with arrays\n  as long as both sets have the same underlying band structure. Properties defined by band\n  may be added to properties defined by g-point; the same value is assumed for all g-points with each band. Subsets of optical properties held as arrays may be extracted along the column dimension. Uses mo_rte_config mo_optical_props_kernels mo_rte_kind mo_rte_util_array_validation module~~mo_optical_props~~UsesGraph module~mo_optical_props mo_optical_props module~mo_rte_config mo_rte_config module~mo_optical_props->module~mo_rte_config mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels mo_rte_kind mo_rte_kind module~mo_optical_props->mo_rte_kind module~mo_rte_util_array_validation mo_rte_util_array_validation module~mo_optical_props->module~mo_rte_util_array_validation module~mo_rte_config->mo_rte_kind module~mo_rte_util_array_validation->mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_optical_props~~UsedByGraph module~mo_optical_props mo_optical_props module~mo_source_functions mo_source_functions module~mo_source_functions->module~mo_optical_props module~mo_fluxes mo_fluxes module~mo_fluxes->module~mo_optical_props module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_optical_props module~mo_rte_lw->module~mo_source_functions module~mo_rte_lw->module~mo_fluxes module~mo_rte_sw mo_rte_sw module~mo_rte_sw->module~mo_optical_props module~mo_rte_sw->module~mo_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables name_len Derived Types ty_optical_props ty_optical_props_1scl ty_optical_props_2str ty_optical_props_arry ty_optical_props_nstr Variables Type Visibility Attributes Name Initial integer, public, parameter :: name_len = 32 Derived Types type, public :: ty_optical_props Describes the spectral discretization including the wavenumber limits\n  of each band (spectral region) and the mapping between g-points and bands Read more… Type-Bound Procedures procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: expand procedure, public :: finalize => finalize_base procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ngpt procedure, public :: gpoints_are_equal generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name type, public, extends( ty_optical_props_arry ) :: ty_optical_props_1scl ty_optical_props_arry represents optical properties as arrays with dimensions\n      column, height, spectral point\n  - Class 1-scalar only (extinction) optical depth\n  -  Class two-stream adds arrays for single scattering albedo ssa and\n     asymmetry parameter needed in two-stream methods\n  - Class n-stream adds arrays for single scattering albedo ssa and\n     phase function moments (index 1 = g) for use with discrete ordinate methods Read more… Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_1scl => alloc_only_1scl, init_and_alloc_1scl, copy_and_alloc_1scl procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: delta_scale => delta_scale_1scl procedure, public :: expand procedure, public :: finalize => finalize_base procedure, public :: finalize_1scl procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol procedure, public :: get_ngpt procedure, public :: get_nlay procedure, public :: get_subset => subset_1scl_range procedure, public :: gpoints_are_equal procedure, public :: increment Increment another set of values generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name procedure, public :: set_top_at_1 procedure, public :: top_is_at_1 procedure, public :: validate => validate_1scalar type, public, extends( ty_optical_props_arry ) :: ty_optical_props_2str Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:), allocatable :: g asymmetry parameter (ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: ssa single-scattering albedo (ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_2str => alloc_only_2str, init_and_alloc_2str, copy_and_alloc_2str procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: delta_scale => delta_scale_2str procedure, public :: expand procedure, public :: finalize => finalize_base procedure, public :: finalize_2str procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol procedure, public :: get_ngpt procedure, public :: get_nlay procedure, public :: get_subset => subset_2str_range procedure, public :: gpoints_are_equal procedure, public :: increment Increment another set of values generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name procedure, public :: set_top_at_1 procedure, public :: top_is_at_1 procedure, public :: validate => validate_2stream type, public, abstract, extends( ty_optical_props ) :: ty_optical_props_arry The abstract base class for arrays defines what procedures will be available Read more… Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure(delta_scale_abstract), public :: delta_scale procedure, public :: expand procedure, public :: finalize => finalize_base procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol procedure, public :: get_ngpt procedure, public :: get_nlay procedure(subset_range_abstract), public :: get_subset procedure, public :: gpoints_are_equal procedure, public :: increment Increment another set of values generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name procedure, public :: set_top_at_1 procedure, public :: top_is_at_1 procedure(validate_abstract), public :: validate Deferred procedures -- each must be implemented in each child class with\n  arguments following the abstract interface (defined below) type, public, extends( ty_optical_props_arry ) :: ty_optical_props_nstr Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:,:,:), allocatable :: p phase-function moments (nmom, ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: ssa single-scattering albedo (ncol, nlay, ngpt) real(kind=wp), public, dimension(:,:,:), allocatable :: tau optical depth (ncol, nlay, ngpt) Type-Bound Procedures generic, public :: alloc_nstr => alloc_only_nstr, init_and_alloc_nstr, copy_and_alloc_nstr procedure, public :: bands_are_equal procedure, public :: convert_band2gpt procedure, public :: convert_gpt2band procedure, public :: delta_scale => delta_scale_nstr procedure, public :: expand procedure, public :: finalize => finalize_base procedure, public :: finalize_nstr procedure, public :: get_band_lims_gpoint procedure, public :: get_band_lims_wavelength procedure, public :: get_band_lims_wavenumber procedure, public :: get_gpoint_bands procedure, public :: get_name procedure, public :: get_nband procedure, public :: get_ncol procedure, public :: get_ngpt procedure, public :: get_nlay procedure, public :: get_nmom procedure, public :: get_subset => subset_nstr_range procedure, public :: gpoints_are_equal procedure, public :: increment Increment another set of values generic, public :: init => init_base, init_base_from_copy procedure, public :: is_initialized => is_initialized_base procedure, public :: set_name procedure, public :: set_top_at_1 procedure, public :: top_is_at_1 procedure, public :: validate => validate_nstream","tags":"","loc":"module/mo_optical_props.html"},{"title":"mo_fluxes – RTE-Fortran","text":"Compute output quantities from spectrally-resolved flux profiles This module contains an abstract class and a broadband implmentation that sums over all spectral points\n   The abstract base class defines the routines that extenstions must implement: reduce() and are_desired() The intent is for users to extend it as required, using mo_flxues_broadband as an example Uses mo_optical_props mo_rte_util_array_validation mo_fluxes_broadband_kernels mo_rte_config mo_rte_kind module~~mo_fluxes~~UsesGraph module~mo_fluxes mo_fluxes module~mo_optical_props mo_optical_props module~mo_fluxes->module~mo_optical_props mo_fluxes_broadband_kernels mo_fluxes_broadband_kernels module~mo_fluxes->mo_fluxes_broadband_kernels module~mo_rte_config mo_rte_config module~mo_fluxes->module~mo_rte_config mo_rte_kind mo_rte_kind module~mo_fluxes->mo_rte_kind module~mo_rte_util_array_validation mo_rte_util_array_validation module~mo_fluxes->module~mo_rte_util_array_validation module~mo_optical_props->module~mo_rte_config module~mo_optical_props->mo_rte_kind module~mo_optical_props->module~mo_rte_util_array_validation mo_optical_props_kernels mo_optical_props_kernels module~mo_optical_props->mo_optical_props_kernels module~mo_rte_config->mo_rte_kind module~mo_rte_util_array_validation->mo_rte_kind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mo_fluxes~~UsedByGraph module~mo_fluxes mo_fluxes module~mo_rte_lw mo_rte_lw module~mo_rte_lw->module~mo_fluxes module~mo_rte_sw mo_rte_sw module~mo_rte_sw->module~mo_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types ty_fluxes ty_fluxes_broadband Derived Types type, public, abstract :: ty_fluxes Abstract base class: reduce() function accepts spectral flux profiles, computes desired outputs are_desired() returns a logical Type-Bound Procedures procedure(are_desired_abstract), public :: are_desired procedure(reduce_abstract), public :: reduce type, public, extends( ty_fluxes ) :: ty_fluxes_broadband Class implementing broadband integration for the complete flux profile.\n  Data components are pointers so results can be written directly into memory Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:), pointer :: flux_dn => NULL() real(kind=wp), public, dimension(:,:), pointer :: flux_dn_dir => NULL() real(kind=wp), public, dimension(:,:), pointer :: flux_net => NULL() real(kind=wp), public, dimension(:,:), pointer :: flux_up => NULL() Type-Bound Procedures procedure, public :: are_desired => are_desired_broadband procedure, public :: reduce => reduce_broadband","tags":"","loc":"module/mo_fluxes.html"},{"title":"mo_rte_lw.F90 – RTE-Fortran","text":"This file depends on sourcefile~~mo_rte_lw.f90~~EfferentGraph sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_util_array_validation.f90 mo_rte_util_array_validation.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_util_array_validation.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array_validation.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array_validation.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_lw Source Code mo_rte_lw.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-  Atmospheric and Environmental Research, !    Regents of the University of Colorado, !    Trustees of Columbia University in the City of New York ! All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! !> Compute longwave radiative fluxes !> !>  Contains a single routine to compute direct and diffuse fluxes of solar radiation given !> !> - atmospheric optical properties, spectrally-resolved via one of the sub-classes of !>     [[mo_optical_props(module):ty_optical_props_arry(type)]] in module [[mo_optical_props]] !      (ty_optical_props_arry in module mo_optical_props) !> - information about vertical ordering !> - internal Planck source functions, defined per g-point on the same spectral grid at the atmosphere, !>     via [[mo_source_functions(module):ty_source_func_lw(type)]] in module [[mo_source_functions]] !      (ty_source_func_lw in module mo_source_functions) !> -  boundary conditions: surface emissivity defined per band !> -  optionally, a boundary condition for incident diffuse radiation !> -  optionally, an integer number of angles at which to do Gaussian quadrature if scattering is neglected !> !> If optical properties are supplied via class ty_optical_props_1scl (absorption optical thickenss only) !>    ([[mo_optical_props(module):ty_optical_props_1scl(type)]] in module [[mo_optical_props]]) !>    then an emission/absorption solver is called. !>    If optical properties are supplied via class ty_optical_props_2str !>    ([[mo_optical_props(module):ty_optical_props_2str(type)]] in module [[mo_optical_props]]) !>    fluxes are computed via a rescaling by default or, optionally, using two-stream calculations and adding. !> !> Users must ensure that emissivity is on the same spectral grid as the optical properties. !> !> Final output is via user-extensible ty_fluxes !> ([[mo_fluxes(module):ty_fluxes(type)]] in module [[mo_fluxes]]) !> which must reduce the detailed spectral fluxes to whatever summary the user needs ! !> The routine does error checking and choses which lower-level kernel to invoke based on !>   what kinds of optical properties are supplied ! ! ------------------------------------------------------------------------------------------------- module mo_rte_lw use mo_rte_kind , only : wp , wl use mo_rte_config , only : check_extents , check_values use mo_rte_util_array , only : zero_array use mo_rte_util_array_validation , & only : any_vals_less_than , any_vals_outside , extents_are use mo_optical_props , only : ty_optical_props , & ty_optical_props_arry , ty_optical_props_1scl , ty_optical_props_2str , ty_optical_props_nstr use mo_source_functions , & only : ty_source_func_lw use mo_fluxes , only : ty_fluxes , ty_fluxes_broadband use mo_rte_solver_kernels , & only : lw_solver_noscat , lw_solver_2stream implicit none private public :: rte_lw contains ! -------------------------------------------------- ! ! Interface using only optical properties and source functions as inputs; fluxes as outputs. ! ! -------------------------------------------------- function rte_lw ( optical_props , & sources , sfc_emis , & fluxes , & inc_flux , n_gauss_angles , use_2stream , & lw_Ds , flux_up_Jac ) result ( error_msg ) class ( ty_optical_props_arry ), intent ( in ) :: optical_props !! Set of optical properties as one or more arrays type ( ty_source_func_lw ), intent ( in ) :: sources !! Derived type with Planck source functions real ( wp ), dimension (:,:), intent ( in ) :: sfc_emis !! emissivity at surface [] (nband, ncol) class ( ty_fluxes ), intent ( inout ) :: fluxes !! Dervied type for computing spectral integrals from g-point fluxes. !! Default computes broadband fluxes at all levels if output arrays are defined. Can be extended per user desires. real ( wp ), dimension (:,:), & target , optional , intent ( in ) :: inc_flux !! incident flux at domain top [W/m2] (ncol, ngpts) integer , optional , intent ( in ) :: n_gauss_angles !! Number of angles used in Gaussian quadrature (max 3, no-scattering solution) logical , optional , intent ( in ) :: use_2stream !! When 2-stream parameters (tau/ssa/g) are provided, use 2-stream methods !! Default is to use re-scaled longwave transport real ( wp ), dimension (:,:), & optional , intent ( in ) :: lw_Ds !! User-specifed 1/cos of transport angle per col, g-point real ( wp ), dimension (:,:), target , & optional , intent ( inout ) :: flux_up_Jac !! surface temperature flux  Jacobian [W/m2/K] (ncol, nlay+1) character ( len = 128 ) :: error_msg !! If empty, calculation was successful ! -------------------------------- ! ! Local variables ! integer :: ncol , nlay , ngpt , nband integer :: icol , ilev , igpt , imu integer :: n_quad_angs logical ( wl ) :: using_2stream , do_Jacobians , do_broadband real ( wp ), dimension (:,:), allocatable :: sfc_emis_gpt real ( wp ), dimension (:,:,:), allocatable :: secants real ( wp ), dimension (:,:), pointer :: jacobian real ( wp ), dimension ( optical_props % get_ncol (), & optical_props % get_nlay () + 1 ), target & :: decoy2D ! Used for optional outputs - needs to be full size. ! Memory needs to be allocated for the full g-point fluxes even if they aren't !    used later because a) the GPU kernels use this memory to work in parallel and !    b) the fluxes are intent(out) in the solvers ! Shortwave solver takes a different approach since three fields are needed real ( wp ), dimension ( optical_props % get_ncol (), & optical_props % get_nlay () + 1 , & optical_props % get_ngpt ()) & :: gpt_flux_up , gpt_flux_dn real ( wp ), dimension (:,:), pointer :: flux_dn_loc , flux_up_loc real ( wp ), dimension (:,:), pointer :: inc_flux_diffuse ! -------------------------------------------------- ! ! Weights and angle secants for \"Gauss-Jacobi-5\" quadrature. !   Values from Table 1, R. J. Hogan 2023, doi:10.1002/qj.4598 ! integer , parameter :: max_gauss_pts = 4 real ( wp ), parameter , & dimension ( max_gauss_pts , max_gauss_pts ) :: & ! ! Values provided are for mu = cos(theta); we require the inverse ! gauss_Ds = 1._wp / & RESHAPE ([ 0.6096748751_wp , huge ( 1._wp ) , huge ( 1._wp ) , huge ( 1._wp ), & 0.2509907356_wp , 0.7908473988_wp , huge ( 1._wp ) , huge ( 1._wp ), & 0.1024922169_wp , 0.4417960320_wp , 0.8633751621_wp , huge ( 1._wp ), & 0.0454586727_wp , 0.2322334416_wp , 0.5740198775_wp , 0.9030775973_wp ], & [ max_gauss_pts , max_gauss_pts ]), & gauss_wts = RESHAPE ([ 1._wp , 0._wp , 0._wp , 0._wp , & 0.2300253764_wp , 0.7699746236_wp , 0._wp , 0._wp , & 0.0437820218_wp , 0.3875796738_wp , 0.5686383044_wp , 0._wp , & 0.0092068785_wp , 0.1285704278_wp , 0.4323381850_wp , 0.4298845087_wp ], & [ max_gauss_pts , max_gauss_pts ]) ! ------------------------------------------------------------------------------------ ncol = optical_props % get_ncol () nlay = optical_props % get_nlay () ngpt = optical_props % get_ngpt () nband = optical_props % get_nband () do_Jacobians = present ( flux_up_Jac ) error_msg = \"\" ! ------------------------------------------------------------------------------------ ! ! Error checking -- input consistency of sizes and validity of values if (. not . fluxes % are_desired ()) & error_msg = \"rte_lw: no space allocated for fluxes\" if ( do_Jacobians . and . check_extents ) then if ( . not . extents_are ( flux_up_Jac , ncol , nlay + 1 )) & error_msg = \"rte_lw: flux Jacobian inconsistently sized\" endif if ( check_extents ) then ! ! Source functions ! if ( any ([ sources % get_ncol (), sources % get_nlay (), sources % get_ngpt ()] /= [ ncol , nlay , ngpt ])) & error_msg = \"rte_lw: sources and optical properties inconsistently sized\" ! ! Surface emissivity ! if (. not . extents_are ( sfc_emis , nband , ncol )) & error_msg = \"rte_lw: sfc_emis inconsistently sized\" ! ! Incident flux, if present ! if ( present ( inc_flux )) then if (. not . extents_are ( inc_flux , ncol , ngpt )) & error_msg = \"rte_lw: inc_flux inconsistently sized\" end if if ( present ( lw_Ds )) then if (. not . extents_are ( lw_Ds , ncol , ngpt )) & error_msg = \"rte_lw: lw_Ds inconsistently sized\" end if end if if ( check_values ) then if ( any_vals_outside ( sfc_emis , 0._wp , 1._wp )) & error_msg = \"rte_lw: sfc_emis has values < 0 or > 1\" if ( present ( inc_flux )) then if ( any_vals_less_than ( inc_flux , 0._wp )) & error_msg = \"rte_lw: inc_flux has values < 0\" end if if ( present ( lw_Ds )) then if ( any_vals_less_than ( lw_Ds , 1._wp )) & error_msg = \"rte_lw: one or more values of lw_Ds < 1.\" end if if ( present ( n_gauss_angles )) then if ( n_gauss_angles > max_gauss_pts ) & error_msg = \"rte_lw: asking for too many quadrature points for no-scattering calculation\" if ( n_gauss_angles < 1 ) & error_msg = \"rte_lw: have to ask for at least one quadrature point for no-scattering calculation\" end if end if if ( len_trim ( error_msg ) > 0 ) return ! ! Number of quadrature points for no-scattering calculation ! n_quad_angs = 1 if ( present ( n_gauss_angles )) n_quad_angs = n_gauss_angles ! ! Optionally - use 2-stream methods when low-order scattering properties are provided? ! using_2stream = . false . if ( present ( use_2stream )) using_2stream = use_2stream ! ! Checking that optional arguments are consistent with one another and with optical properties ! select type ( optical_props ) class is ( ty_optical_props_1scl ) if ( using_2stream ) & error_msg = \"rte_lw: can't use two-stream methods with only absorption optical depth\" if ( present ( lw_Ds ) . and . n_quad_angs /= 1 ) & error_msg = \"rte_lw: providing lw_Ds incompatible with specifying n_gauss_angles\" class is ( ty_optical_props_2str ) if ( present ( lw_Ds )) & error_msg = \"rte_lw: lw_Ds not valid when providing scattering optical properties\" if ( using_2stream . and . n_quad_angs /= 1 ) & error_msg = \"rte_lw: using_2stream=true incompatible with specifying n_gauss_angles\" if ( using_2stream . and . do_Jacobians ) & error_msg = \"rte_lw: can't provide Jacobian of fluxes w.r.t surface temperature with 2-stream\" class default error_msg = \"rte_lw: lw_solver(...ty_optical_props_nstr...) not yet implemented\" end select if ( len_trim ( error_msg ) > 0 ) then if ( len_trim ( optical_props % get_name ()) > 0 ) & error_msg = trim ( optical_props % get_name ()) // ': ' // trim ( error_msg ) return end if ! ------------------------------------------------------------------------------------ !  Boundary conditions !    Lower boundary condition -- expand surface emissivity by band to gpoints ! allocate ( sfc_emis_gpt ( ncol , ngpt )) !   Upper boundary condition -  use values in optional arg or be set to 0 ! if ( present ( inc_flux )) then inc_flux_diffuse => inc_flux !$acc        enter data copyin(   inc_flux_diffuse) !$omp target enter data map(to:   inc_flux_diffuse) else allocate ( inc_flux_diffuse ( ncol , ngpt )) !$acc        enter data create(   inc_flux_diffuse) !$omp target enter data map(alloc:inc_flux_diffuse) call zero_array ( ncol , ngpt , inc_flux_diffuse ) end if ! ------------------------------------------------------------------------------------ if ( do_Jacobians ) then jacobian => flux_up_Jac else jacobian => decoy2D end if select type ( fluxes ) ! ! Broadband fluxes are treated as a special case within the solvers; memory !   for both up and down fluxes needs to be available even if the user doesn't !   want one of them ! type is ( ty_fluxes_broadband ) do_broadband = . true . _ wl ! ! Broadband fluxes class has three possible outputs; allocate memory for local use !   if one or more haven't been requested ! if ( associated ( fluxes % flux_up )) then flux_up_loc => fluxes % flux_up else allocate ( flux_up_loc ( ncol , nlay + 1 )) end if if ( associated ( fluxes % flux_dn )) then flux_dn_loc => fluxes % flux_dn else allocate ( flux_dn_loc ( ncol , nlay + 1 )) end if !$acc        enter data create(   flux_up_loc, flux_dn_loc) !$omp target enter data map(alloc:flux_up_loc, flux_dn_loc) class default ! ! If broadband integrals aren't being computed, allocate working space !   and decoy addresses for spectrally-integrated fields ! do_broadband = . false . _ wl flux_up_loc => decoy2D flux_dn_loc => decoy2D end select ! ! Compute the radiative transfer... ! !$acc        data create(   sfc_emis_gpt, flux_up_loc, flux_dn_loc, gpt_flux_up, gpt_flux_dn) !$omp target data map(alloc:sfc_emis_gpt, flux_up_loc, flux_dn_loc, gpt_flux_up, gpt_flux_dn) call expand_and_transpose ( optical_props , sfc_emis , sfc_emis_gpt ) if ( check_values ) error_msg = optical_props % validate () if ( len_trim ( error_msg ) == 0 ) then ! Can't do an early return within OpenACC/MP data regions select type ( optical_props ) class is ( ty_optical_props_1scl ) ! ! No scattering two-stream calculation ! ! ! Secant of radiation angle - either user-supplied, one per g-point, or !   taken from first-order Gaussian quadrate and applied to all columns a g-points ! allocate ( secants ( ncol , ngpt , n_quad_angs )) !$acc        data create(   secants) !$omp target data map(alloc:secants) if ( present ( lw_Ds )) then !$acc                         parallel loop    collapse(2) copyin(lw_Ds) !$omp target teams distribute parallel do simd collapse(2) ! nmu is 1 do igpt = 1 , ngpt do icol = 1 , ncol secants ( icol , igpt , 1 ) = lw_Ds ( icol , igpt ) end do end do else ! !   Is there an alternative to making ncol x ngpt copies of each value? ! !$acc                         parallel loop    collapse(3) !$omp target teams distribute parallel do simd collapse(3) do imu = 1 , n_quad_angs do igpt = 1 , ngpt do icol = 1 , ncol secants ( icol , igpt , imu ) = gauss_Ds ( imu , n_quad_angs ) end do end do end do end if call lw_solver_noscat ( ncol , nlay , ngpt , & logical ( optical_props % top_is_at_1 (), wl ), & n_quad_angs , secants , gauss_wts ( 1 : n_quad_angs , n_quad_angs ), & optical_props % tau , & sources % lay_source , & sources % lev_source , & sfc_emis_gpt , sources % sfc_source , & inc_flux_diffuse , & gpt_flux_up , gpt_flux_dn , & do_broadband , flux_up_loc , flux_dn_loc , & logical ( do_Jacobians , wl ), sources % sfc_source_Jac , jacobian , & logical (. false ., wl ), optical_props % tau , optical_props % tau ) ! The last two arguments won't be used since the ! third-to-last is .false. but need valid addresses !$acc        end data !$omp end target data class is ( ty_optical_props_2str ) if ( using_2stream ) then ! ! two-stream calculation with scattering ! call lw_solver_2stream ( ncol , nlay , ngpt , & logical ( optical_props % top_is_at_1 (), wl ), & optical_props % tau , optical_props % ssa , optical_props % g , & sources % lay_source , sources % lev_source , & sfc_emis_gpt , sources % sfc_source , & inc_flux_diffuse , & gpt_flux_up , gpt_flux_dn ) else allocate ( secants ( ncol , ngpt , n_quad_angs )) !$acc        data create(   secants) !$omp target data map(alloc:secants) !$acc                         parallel loop    collapse(3) !$omp target teams distribute parallel do simd collapse(3) do imu = 1 , n_quad_angs do igpt = 1 , ngpt do icol = 1 , ncol secants ( icol , igpt , imu ) = gauss_Ds ( imu , n_quad_angs ) end do end do end do ! ! Re-scaled solution to account for scattering ! call lw_solver_noscat ( ncol , nlay , ngpt , & logical ( optical_props % top_is_at_1 (), wl ), & n_quad_angs , & secants , gauss_wts ( 1 : n_quad_angs , n_quad_angs ), & optical_props % tau , & sources % lay_source , & sources % lev_source , & sfc_emis_gpt , sources % sfc_source , & inc_flux_diffuse , & gpt_flux_up , gpt_flux_dn , & do_broadband , flux_up_loc , flux_dn_loc , & logical ( do_Jacobians , wl ), sources % sfc_source_Jac , jacobian , & logical (. true ., wl ), optical_props % ssa , optical_props % g ) !$acc        end data !$omp end target data endif class is ( ty_optical_props_nstr ) ! ! n-stream calculation ! error_msg = 'lw_solver(...ty_optical_props_nstr...) not yet implemented' end select select type ( fluxes ) ! ! Tidy up memory for broadband fluxes on GPUs ! type is ( ty_fluxes_broadband ) if ( associated ( fluxes % flux_net )) then ! ! FIXME: Do we need the create/copyout here? ! !$acc parallel loop    collapse(2) copyin(fluxes) copyout( fluxes%flux_net) !$omp target teams distribute parallel do simd collapse(2) map(from:fluxes%flux_net) do ilev = 1 , nlay + 1 do icol = 1 , ncol fluxes % flux_net ( icol , ilev ) = flux_dn_loc ( icol , ilev ) - flux_up_loc ( icol , ilev ) end do end do end if class default ! ! ...or reduce spectral fluxes to desired output quantities ! error_msg = fluxes % reduce ( gpt_flux_up , gpt_flux_dn , optical_props , optical_props % top_is_at_1 ()) end select end if ! no error message from validation !$acc        end data !$omp end target data if (. not . present ( inc_flux )) then !$acc        exit data delete(     inc_flux_diffuse) !$omp target exit data map(release:inc_flux_diffuse) deallocate ( inc_flux_diffuse ) end if select type ( fluxes ) type is ( ty_fluxes_broadband ) !$acc        exit data copyout( flux_up_loc, flux_dn_loc) !$omp target exit data map(from:flux_up_loc, flux_dn_loc) if (. not . associated ( flux_up_loc , fluxes % flux_up )) deallocate ( flux_up_loc ) if (. not . associated ( flux_dn_loc , fluxes % flux_dn )) deallocate ( flux_dn_loc ) end select end function rte_lw !-------------------------------------------------------------------------------------------------------------------- ! ! Expand from band to g-point dimension, transpose dimensions (nband, ncol) -> (ncol,ngpt) ! subroutine expand_and_transpose ( ops , arr_in , arr_out ) class ( ty_optical_props ), intent ( in ) :: ops real ( wp ), dimension (:,:), intent ( in ) :: arr_in ! (nband, ncol) real ( wp ), dimension (:,:), intent ( out ) :: arr_out ! (ncol, igpt) ! ------------- integer :: ncol , nband , ngpt integer :: icol , iband , igpt integer , dimension ( 2 , ops % get_nband ()) :: limits ncol = size ( arr_in , 2 ) nband = ops % get_nband () ngpt = ops % get_ngpt () limits = ops % get_band_lims_gpoint () !$acc                         parallel loop    collapse(2) copyin(arr_in, limits) !$omp target teams distribute parallel do simd collapse(2) map(to:arr_in, limits) do iband = 1 , nband do icol = 1 , ncol do igpt = limits ( 1 , iband ), limits ( 2 , iband ) arr_out ( icol , igpt ) = arr_in ( iband , icol ) end do end do end do end subroutine expand_and_transpose !-------------------------------------------------------------------------------------------------------------------- end module mo_rte_lw","tags":"","loc":"sourcefile/mo_rte_lw.f90.html"},{"title":"mo_rte_util_array_validation.F90 – RTE-Fortran","text":"Files dependent on this one sourcefile~~mo_rte_util_array_validation.f90~~AfferentGraph sourcefile~mo_rte_util_array_validation.f90 mo_rte_util_array_validation.F90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_util_array_validation.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array_validation.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array_validation.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_util_array_validation.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_util_array_validation Source Code mo_rte_util_array_validation.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-  Atmospheric and Environmental Research, !    Regents of the University of Colorado, !    Trustees of Columbia University in the City of New York ! All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- module mo_rte_util_array_validation ! !> Provide utilites for sanitizing input arrays: !    checking values and sizes ! These are in a module so code can be written for both CPUs and GPUs ! Used only by Fortran classes so routines don't need C bindings and can use assumed-shape ! use mo_rte_kind , only : wp , wl implicit none !> !> Values less than a floor (including masked versions) !> interface any_vals_less_than module procedure any_vals_less_than_1D , any_vals_less_than_2D , any_vals_less_than_3D module procedure any_vals_less_than_1D_masked , any_vals_less_than_2D_masked , any_vals_less_than_3D_masked end interface !> !> Values outside a range (including masked versions) !> interface any_vals_outside module procedure any_vals_outside_1D , any_vals_outside_2D , any_vals_outside_3D module procedure any_vals_outside_1D_masked , any_vals_outside_2D_masked , any_vals_outside_3D_masked end interface !> !> Find the extents of an array !> interface extents_are module procedure extents_are_1D , extents_are_2D , extents_are_3D module procedure extents_are_4D , extents_are_5D , extents_are_6D module procedure extents_are_2d_int end interface extents_are private public :: any_vals_less_than , any_vals_outside , extents_are contains !------------------------------------------------------------------------------------------------- ! Values less than a floor !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_1D ( array , check_value ) real ( wp ), dimension (:), intent ( in ) :: array real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue !$acc kernels copyin(array) !$omp target map(to:array) map(from:minValue) minValue = minval ( array ) !$acc end kernels !$omp end target any_vals_less_than_1D = ( minValue < check_value ) end function any_vals_less_than_1D !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_2D ( array , check_value ) real ( wp ), dimension (:,:), intent ( in ) :: array real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue !$acc kernels copyin(array) !$omp target map(to:array) map(from:minValue) minValue = minval ( array ) !$acc end kernels !$omp end target any_vals_less_than_2D = ( minValue < check_value ) end function any_vals_less_than_2D !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_3D ( array , check_value ) real ( wp ), dimension (:,:,:), intent ( in ) :: array real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue #ifdef _OPENMP integer :: dim1 , dim2 , dim3 , i , j , k dim1 = size ( array , 1 ) dim2 = size ( array , 2 ) dim3 = size ( array , 3 ) minValue = check_value + epsilon ( check_value ) ! initialize to some value !$omp target teams map(to:array) & !$omp defaultmap(tofrom:scalar) reduction(min:minValue) !$omp distribute parallel do simd reduction(min:minValue) do i = 1 , dim1 do j = 1 , dim2 do k = 1 , dim3 minValue = min ( minValue , array ( i , j , k )) enddo enddo enddo !$omp end target teams #else !$acc kernels copyin(array) minValue = minval ( array ) !$acc end kernels #endif any_vals_less_than_3D = ( minValue < check_value ) end function any_vals_less_than_3D !------------------------------------------------------------------------------------------------- ! Masked versions !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_1D_masked ( array , mask , check_value ) real ( wp ), dimension (:), intent ( in ) :: array logical ( wl ), dimension (:), intent ( in ) :: mask real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue !$acc kernels copyin(array, mask) !$omp target map(to: array, mask) map(from:minValue) minValue = minval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_less_than_1D_masked = ( minValue < check_value ) end function any_vals_less_than_1D_masked !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_2D_masked ( array , mask , check_value ) real ( wp ), dimension (:,:), intent ( in ) :: array logical ( wl ), dimension (:,:), intent ( in ) :: mask real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue !$acc kernels copyin(array, mask) !$omp target map(to: array, mask) map(from:minValue) minValue = minval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_less_than_2D_masked = ( minValue < check_value ) end function any_vals_less_than_2D_masked !------------------------------------------------------------------------------------------------- logical function any_vals_less_than_3D_masked ( array , mask , check_value ) real ( wp ), dimension (:,:,:), intent ( in ) :: array logical ( wl ), dimension (:,:,:), intent ( in ) :: mask real ( wp ), intent ( in ) :: check_value real ( wp ) :: minValue !$acc kernels copyin(array, mask) !$omp target map(to: array, mask) map(from:minValue) minValue = minval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_less_than_3D_masked = ( minValue < check_value ) end function any_vals_less_than_3D_masked !------------------------------------------------------------------------------------------------- ! Values outside a range !------------------------------------------------------------------------------------------------- logical function any_vals_outside_1D ( array , checkMin , checkMax ) real ( wp ), dimension (:), intent ( in ) :: array real ( wp ), intent ( in ) :: checkMin , checkMax real ( wp ) :: minValue , maxValue !$acc kernels copyin(array) !$omp target map(to:array) map(from:minValue, maxValue) minValue = minval ( array ) maxValue = maxval ( array ) !$acc end kernels !$omp end target any_vals_outside_1D = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_1D ! ---------------------------------------------------------- logical function any_vals_outside_2D ( array , checkMin , checkMax ) real ( wp ), dimension (:,:), intent ( in ) :: array real ( wp ), intent ( in ) :: checkMin , checkMax real ( wp ) :: minValue , maxValue !$acc kernels copyin(array) !$omp target map(to:array) map(from:minValue, maxValue) minValue = minval ( array ) maxValue = maxval ( array ) !$acc end kernels !$omp end target any_vals_outside_2D = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_2D ! ---------------------------------------------------------- logical function any_vals_outside_3D ( array , checkMin , checkMax ) real ( wp ), dimension (:,:,:), intent ( in ) :: array real ( wp ), intent ( in ) :: checkMin , checkMax ! Compact version using intrinsics below ! but an explicit loop is the only current solution on GPUs real ( wp ) :: minValue , maxValue #ifdef _OPENMP integer :: dim1 , dim2 , dim3 , i , j , k dim1 = size ( array , 1 ) dim2 = size ( array , 2 ) dim3 = size ( array , 3 ) minValue = checkMin + epsilon ( checkMin ) ! initialize to some value maxValue = checkMax - epsilon ( checkMax ) ! initialize to some value !$omp target teams map(to:array) & !$omp defaultmap(tofrom:scalar) reduction(min:minValue) reduction(max:maxValue) !$omp distribute parallel do simd reduction(min:minValue) reduction(max:maxValue) do i = 1 , dim1 do j = 1 , dim2 do k = 1 , dim3 minValue = min ( minValue , array ( i , j , k )) maxValue = max ( maxValue , array ( i , j , k )) enddo enddo enddo !$omp end target teams #else !$acc kernels copyin(array) minValue = minval ( array ) maxValue = maxval ( array ) !$acc end kernels #endif any_vals_outside_3D = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_3D ! ---------------------------------------------------------- ! Masked versions ! ---------------------------------------------------------- logical function any_vals_outside_1D_masked ( array , mask , checkMin , checkMax ) real ( wp ), dimension (:), intent ( in ) :: array logical ( wl ), dimension (:), intent ( in ) :: mask real ( wp ), intent ( in ) :: checkMin , checkMax real ( wp ) :: minValue , maxValue !$acc kernels copyin(array, mask) !$omp target map(to: array, mask) map(from:minValue, maxValue) minValue = minval ( array , mask = mask ) maxValue = maxval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_outside_1D_masked = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_1D_masked ! ---------------------------------------------------------- logical function any_vals_outside_2D_masked ( array , mask , checkMin , checkMax ) real ( wp ), dimension (:,:), intent ( in ) :: array logical ( wl ), dimension (:,:), intent ( in ) :: mask real ( wp ), intent ( in ) :: checkMin , checkMax real ( wp ) :: minValue , maxValue !$acc kernels copyin(array, mask) !$omp target map(to: array, mask) map(from:minValue, maxValue) minValue = minval ( array , mask = mask ) maxValue = maxval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_outside_2D_masked = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_2D_masked ! ---------------------------------------------------------- logical function any_vals_outside_3D_masked ( array , mask , checkMin , checkMax ) real ( wp ), dimension (:,:,:), intent ( in ) :: array logical ( wl ), dimension (:,:,:), intent ( in ) :: mask real ( wp ), intent ( in ) :: checkMin , checkMax real ( wp ) :: minValue , maxValue !$acc kernels copyin(array, mask) !$omp target map(to: array, mask) map(from:minValue, maxValue) minValue = minval ( array , mask = mask ) maxValue = maxval ( array , mask = mask ) !$acc end kernels !$omp end target any_vals_outside_3D_masked = minValue < checkMin . or . maxValue > checkMax end function any_vals_outside_3D_masked !-------------------------------------------------------------------------------------------------------------------- ! ! Extents ! ! -------------------------------------------------------------------------------------- function extents_are_1d ( array , n1 ) real ( wp ), dimension (: ), intent ( in ) :: array integer , intent ( in ) :: n1 logical ( wl ) :: extents_are_1d extents_are_1d = ( size ( array , 1 ) == n1 ) end function extents_are_1d ! -------------------------------------------------------------------------------------- function extents_are_2d ( array , n1 , n2 ) real ( wp ), dimension (:,: ), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 logical ( wl ) :: extents_are_2d extents_are_2d = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 ) end function extents_are_2d ! -------------------------------------------------------------------------------------- function extents_are_3d ( array , n1 , n2 , n3 ) real ( wp ), dimension (:,:,: ), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 , n3 logical ( wl ) :: extents_are_3d extents_are_3d = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 . and . & size ( array , 3 ) == n3 ) end function extents_are_3d ! -------------------------------------------------------------------------------------- function extents_are_4d ( array , n1 , n2 , n3 , n4 ) real ( wp ), dimension (:,:,:,: ), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 , n3 , n4 logical ( wl ) :: extents_are_4d extents_are_4d = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 . and . & size ( array , 3 ) == n3 . and . & size ( array , 4 ) == n4 ) end function extents_are_4d ! -------------------------------------------------------------------------------------- function extents_are_5d ( array , n1 , n2 , n3 , n4 , n5 ) real ( wp ), dimension (:,:,:,:,: ), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 , n3 , n4 , n5 logical ( wl ) :: extents_are_5d extents_are_5d = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 . and . & size ( array , 3 ) == n3 . and . & size ( array , 4 ) == n4 . and . & size ( array , 5 ) == n5 ) end function extents_are_5d ! -------------------------------------------------------------------------------------- function extents_are_6d ( array , n1 , n2 , n3 , n4 , n5 , n6 ) real ( wp ), dimension (:,:,:,:,:,:), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 , n3 , n4 , n5 , n6 logical ( wl ) :: extents_are_6d extents_are_6d = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 . and . & size ( array , 3 ) == n3 . and . & size ( array , 4 ) == n4 . and . & size ( array , 5 ) == n5 . and . & size ( array , 6 ) == n6 ) end function extents_are_6d ! -------------------------------------------------------------------------------------- function extents_are_2d_int ( array , n1 , n2 ) integer , dimension (:,: ), intent ( in ) :: array integer , intent ( in ) :: n1 , n2 logical ( wl ) :: extents_are_2d_int extents_are_2d_int = ( size ( array , 1 ) == n1 . and . & size ( array , 2 ) == n2 ) end function extents_are_2d_int end module mo_rte_util_array_validation","tags":"","loc":"sourcefile/mo_rte_util_array_validation.f90.html"},{"title":"mo_rte_config.F90 – RTE-Fortran","text":"Files dependent on this one sourcefile~~mo_rte_config.f90~~AfferentGraph sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_config Source Code mo_rte_config.F90 Source Code ! This code is part of RRTM for GCM Applications - Parallel (RRTMGP) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2020-  Atmospheric and Environmental Research, !    Regents of the University of Colorado, !    Trustees of Columbia University in the City of New York ! All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause !> ------------------------------------------------------------------------------------------------- !> !> ## Control input sanitization in Fortan front-end !>   Provides public access to two proteced module variables !> !> ------------------------------------------------------------------------------------------------- module mo_rte_config use mo_rte_kind , only : wl implicit none private logical ( wl ), protected , public :: check_extents = . true . logical ( wl ), protected , public :: check_values = . true . !> Specify checking of extents and values individually, or all checks together interface rte_config_checks module procedure rte_config_checks_each , rte_config_checks_all end interface public :: rte_config_checks contains ! -------------------------------------------------------------- !> Do extents and/or values checks within RTE+RRTMGP Fortran classes subroutine rte_config_checks_each ( extents , values ) logical ( wl ), intent ( in ) :: extents , values check_extents = extents check_values = values end subroutine rte_config_checks_each ! -------------------------------------------------------------- !> Do all checks within RTE+RRTMGP Fortran classes subroutine rte_config_checks_all ( do_checks ) logical ( wl ), intent ( in ) :: do_checks check_extents = do_checks check_values = do_checks end subroutine rte_config_checks_all ! -------------------------------------------------------------- end module mo_rte_config","tags":"","loc":"sourcefile/mo_rte_config.f90.html"},{"title":"mo_rte_sw.F90 – RTE-Fortran","text":"This file depends on sourcefile~~mo_rte_sw.f90~~EfferentGraph sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_util_array_validation.f90 mo_rte_util_array_validation.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_rte_util_array_validation.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array_validation.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array_validation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_rte_sw Source Code mo_rte_sw.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-,  Atmospheric and Environmental Research, ! Regents of the University of Colorado, Trustees of Columbia University.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! !> Compute shortwave radiative fluxes !>  Contains a single routine to compute direct and diffuse fluxes of solar radiation given !> !>  - atmospheric optical properties on a spectral grid !>  - information about vertical ordering !>  - boundary conditions !>    - solar zenith angle, spectrally-resolved incident colimated flux, surface albedos for direct and diffuse radiation !>    - optionally, a boundary condition for incident diffuse radiation !> !> It is the user's responsibility to ensure that boundary conditions (incident fluxes, surface albedos) are on the same !>   spectral grid as the optical properties. !> !> Final output is via user-extensible ty_fluxes !> ([[mo_fluxes(module):ty_fluxes(type)]] in module [[mo_fluxes]]) !> which must reduce the detailed spectral fluxes to whatever summary the user needs !> !> !> The routine does error checking and choses which lower-level kernel to invoke based on !>   what kinds of optical properties are supplied ! ! ------------------------------------------------------------------------------------------------- module mo_rte_sw use mo_rte_kind , only : wp , wl use mo_rte_config , only : check_extents , check_values use mo_rte_util_array , only : zero_array use mo_rte_util_array_validation , & only : any_vals_less_than , any_vals_outside , extents_are use mo_optical_props , only : ty_optical_props , & ty_optical_props_arry , ty_optical_props_1scl , ty_optical_props_2str , ty_optical_props_nstr use mo_fluxes , only : ty_fluxes , ty_fluxes_broadband use mo_rte_solver_kernels , & only : sw_solver_noscat , sw_solver_2stream implicit none private interface rte_sw module procedure rte_sw_mu0_bycol , rte_sw_mu0_full end interface rte_sw public :: rte_sw contains ! ------------------------------------------------------------------------------------------------- function rte_sw_mu0_bycol ( atmos , & mu0 , inc_flux , & sfc_alb_dir , sfc_alb_dif , & fluxes , inc_flux_dif ) result ( error_msg ) class ( ty_optical_props_arry ), intent ( in ) :: atmos !! Optical properties provided as arrays real ( wp ), dimension (:), intent ( in ) :: mu0 !! cosine of solar zenith angle (ncol) - will be assumed constant with height real ( wp ), dimension (:,:), intent ( in ) :: inc_flux !! incident flux at top of domain [W/m2] (ncol, ngpt) real ( wp ), dimension (:,:), intent ( in ) :: sfc_alb_dir !! surface albedo for direct and real ( wp ), dimension (:,:), intent ( in ) :: sfc_alb_dif !! diffuse radiation (nband, ncol) class ( ty_fluxes ), intent ( inout ) :: fluxes !! Class describing output calculations real ( wp ), dimension (:,:), optional , target , & intent ( in ) :: inc_flux_dif !! incident diffuse flux at top of domain [W/m2] (ncol, ngpt) character ( len = 128 ) :: error_msg !! If empty, calculation was successful ! -------------------------------- real ( wp ), dimension ( size ( mu0 ), atmos % get_nlay ()) :: mu0_bylay integer :: i , j , ncol , nlay ncol = size ( mu0 ) nlay = atmos % get_nlay () ! Solar zenith angle cosine is constant with height !$acc        data copyin(mu0)    create(mu0_bylay) !$omp target data map(to:mu0) map(alloc:mu0_bylay) !$acc                         parallel loop    collapse(2) !$omp target teams distribute parallel do simd collapse(2) do j = 1 , nlay do i = 1 , ncol mu0_bylay ( i , j ) = mu0 ( i ) end do end do error_msg = rte_sw_mu0_full ( atmos , & mu0_bylay , inc_flux , & sfc_alb_dir , sfc_alb_dif , & fluxes , inc_flux_dif ) !$acc end data !$omp end target data end function rte_sw_mu0_bycol ! ------------------------------------------------------------------------------------------------- function rte_sw_mu0_full ( atmos , mu0 , inc_flux , & sfc_alb_dir , sfc_alb_dif , & fluxes , inc_flux_dif ) result ( error_msg ) class ( ty_optical_props_arry ), intent ( in ) :: atmos !! Optical properties provided as arrays real ( wp ), dimension (:,:), intent ( in ) :: mu0 !! cosine of solar zenith angle (ncol, nlay) real ( wp ), dimension (:,:), intent ( in ) :: inc_flux !! incident flux at top of domain [W/m2] (ncol, ngpt) real ( wp ), dimension (:,:), intent ( in ) :: sfc_alb_dir !! surface albedo for direct and real ( wp ), dimension (:,:), intent ( in ) :: sfc_alb_dif !! diffuse radiation (nband, ncol) class ( ty_fluxes ), intent ( inout ) :: fluxes !! Class describing output calculations real ( wp ), dimension (:,:), optional , target , & intent ( in ) :: inc_flux_dif !! incident diffuse flux at top of domain [W/m2] (ncol, ngpt) character ( len = 128 ) :: error_msg !! If empty, calculation was successful ! -------------------------------- ! ! Local variables ! integer :: ncol , nlay , ngpt , nband integer :: icol , ilev logical ( wl ) :: has_dif_bc , do_broadband real ( wp ), dimension (:,:,:), pointer :: gpt_flux_up , gpt_flux_dn , gpt_flux_dir real ( wp ), dimension (:,:), allocatable :: sfc_alb_dir_gpt , sfc_alb_dif_gpt real ( wp ), dimension (:,:), pointer :: flux_dn_loc , flux_up_loc , flux_dir_loc real ( wp ), dimension (:,:), pointer :: inc_flux_diffuse real ( wp ), dimension (:,:,:), allocatable , target :: decoy3D real ( wp ), dimension (:,:), allocatable , target :: decoy2D ! ------------------------------------------------------------------------------------ ncol = atmos % get_ncol () nlay = atmos % get_nlay () ngpt = atmos % get_ngpt () nband = atmos % get_nband () error_msg = \"\" ! ------------------------------------------------------------------------------------ ! ! Error checking -- consistency of sizes and validity of values ! ! -------------------------------- if (. not . fluxes % are_desired ()) & error_msg = \"rte_sw: no space allocated for fluxes\" has_dif_bc = logical ( present ( inc_flux_dif ), wl ) ! ! Sizes of input arrays ! ! Copy variables whose sizes and values are checked to the GPU so the checks can happen there. !   No harm done if checks are not performed  (?) !$acc        data copyin(mu0, inc_flux, sfc_alb_dir, sfc_alb_dif) !$omp target data map(to:mu0, inc_flux, sfc_alb_dir, sfc_alb_dif) !$acc        data copyin(inc_flux_dif) if (has_dif_bc) !$omp target data map(to:inc_flux_dif) if (has_dif_bc) if ( check_extents ) then if (. not . extents_are ( mu0 , ncol , nlay )) & error_msg = \"rte_sw: mu0 inconsistently sized\" if (. not . extents_are ( inc_flux , ncol , ngpt )) & error_msg = \"rte_sw: inc_flux inconsistently sized\" if (. not . extents_are ( sfc_alb_dir , nband , ncol )) & error_msg = \"rte_sw: sfc_alb_dir inconsistently sized\" if (. not . extents_are ( sfc_alb_dif , nband , ncol )) & error_msg = \"rte_sw: sfc_alb_dif inconsistently sized\" if ( has_dif_bc ) then if (. not . extents_are ( inc_flux_dif , ncol , ngpt )) & error_msg = \"rte_sw: inc_flux_dif inconsistently sized\" end if end if ! ! Values of input arrays ! if ( check_values ) then if ( any_vals_outside ( mu0 , - 1._wp , 1._wp )) & error_msg = \"rte_sw: one or more mu0 < -1 or > 1\" if ( any_vals_less_than ( inc_flux , 0._wp )) & error_msg = \"rte_sw: one or more inc_flux < 0\" if ( any_vals_outside ( sfc_alb_dir , 0._wp , 1._wp )) & error_msg = \"rte_sw: sfc_alb_dir out of bounds [0,1]\" if ( any_vals_outside ( sfc_alb_dif , 0._wp , 1._wp )) & error_msg = \"rte_sw: sfc_alb_dif out of bounds [0,1]\" if ( has_dif_bc ) then if ( any_vals_less_than ( inc_flux_dif , 0._wp )) & error_msg = \"rte_sw: one or more inc_flux_dif < 0\" end if end if ! ------------------------------------------------------------------------------------ select type ( fluxes ) type is ( ty_fluxes_broadband ) do_broadband = . true . _ wl ! ! Solvers will integrate in place (one g-point at a time on CPUs) !   so won't need big working arrays ! allocate ( decoy3D ( ncol , nlay + 1 , ngpt )) gpt_flux_up => decoy3D gpt_flux_dn => decoy3D gpt_flux_dir => decoy3D ! ! Broadband fluxes class has three possible outputs; allocate memory for local use !   if one or more haven't been requested ! if ( associated ( fluxes % flux_up )) then flux_up_loc => fluxes % flux_up else allocate ( flux_up_loc ( ncol , nlay + 1 )) end if if ( associated ( fluxes % flux_dn )) then flux_dn_loc => fluxes % flux_dn else allocate ( flux_dn_loc ( ncol , nlay + 1 )) end if if ( associated ( fluxes % flux_dn_dir )) then flux_dir_loc => fluxes % flux_dn_dir else allocate ( flux_dir_loc ( ncol , nlay + 1 )) end if !$acc        enter data create(   flux_up_loc, flux_dn_loc, flux_dir_loc) !$omp target enter data map(alloc:flux_up_loc, flux_dn_loc, flux_dir_loc) class default ! ! If broadband integrals aren't being computed, allocate working space !   and decoy addresses for spectrally-integrated fields ! do_broadband = . false . _ wl allocate ( decoy2D ( ncol , nlay + 1 )) flux_up_loc => decoy2D flux_dn_loc => decoy2D flux_dir_loc => decoy2D allocate ( gpt_flux_up ( ncol , nlay + 1 , ngpt ), & gpt_flux_dn ( ncol , nlay + 1 , ngpt ), & gpt_flux_dir ( ncol , nlay + 1 , ngpt )) end select allocate ( sfc_alb_dir_gpt ( ncol , ngpt ), sfc_alb_dif_gpt ( ncol , ngpt )) if ( len_trim ( error_msg ) > 0 ) then if ( len_trim ( atmos % get_name ()) > 0 ) & error_msg = trim ( atmos % get_name ()) // ': ' // trim ( error_msg ) end if ! Fluxes need to be copied out only if do_broadband is .true. !$acc        data copyin(   flux_up_loc,flux_dn_loc,flux_dir_loc) if (      do_broadband) !$omp target data map(to:   flux_up_loc,flux_dn_loc,flux_dir_loc) if (      do_broadband) !$acc        data create(   flux_up_loc,flux_dn_loc,flux_dir_loc) if (.not. do_broadband) !$omp target data map(alloc:flux_up_loc,flux_dn_loc,flux_dir_loc) if (.not. do_broadband) !$acc        data create(   gpt_flux_up,gpt_flux_dn,gpt_flux_dir) & !$acc             create(   sfc_alb_dir_gpt, sfc_alb_dif_gpt) !$omp target data map(alloc:gpt_flux_up,gpt_flux_dn,gpt_flux_dir) & !$omp             map(alloc:sfc_alb_dir_gpt, sfc_alb_dif_gpt) ! ------------------------------------------------------------------------------------ ! Boundary conditions !   Lower boundary condition -- expand surface albedos by band to gpoints !     and switch dimension ordering call expand_and_transpose ( atmos , sfc_alb_dir , sfc_alb_dir_gpt ) call expand_and_transpose ( atmos , sfc_alb_dif , sfc_alb_dif_gpt ) ! !   Diffuse flux boundary condition - will use values in optional arg or be set to 0 ! if ( has_dif_bc ) then inc_flux_diffuse => inc_flux_dif !$acc        enter data copyin(   inc_flux_diffuse) !$omp target enter data map(to:   inc_flux_diffuse) else allocate ( inc_flux_diffuse ( ncol , ngpt )) !$acc        enter data create(   inc_flux_diffuse) !$omp target enter data map(alloc:inc_flux_diffuse) call zero_array ( ncol , ngpt , inc_flux_diffuse ) end if ! ------------------------------------------------------------------------------------ if ( check_values ) error_msg = atmos % validate () ! ! Compute the radiative transfer... ! if ( len_trim ( error_msg ) == 0 ) then select type ( atmos ) class is ( ty_optical_props_1scl ) ! ! Direct beam only - for completeness, unlikely to be used in practice ! call sw_solver_noscat ( ncol , nlay , ngpt , & logical ( atmos % top_is_at_1 (), wl ), & atmos % tau , mu0 , inc_flux , & gpt_flux_dir ) call zero_array ( ncol , nlay + 1 , ngpt , gpt_flux_up ) ! !$acc kernels !$omp target gpt_flux_dn (:,:,:) = gpt_flux_dir (:,:,:) !$acc end kernels !$omp end target class is ( ty_optical_props_2str ) ! ! two-stream calculation with scattering ! call sw_solver_2stream ( ncol , nlay , ngpt , & logical ( atmos % top_is_at_1 (), wl ), & atmos % tau , atmos % ssa , atmos % g , mu0 , & sfc_alb_dir_gpt , sfc_alb_dif_gpt , & inc_flux , & gpt_flux_up , gpt_flux_dn , gpt_flux_dir , & has_dif_bc , inc_flux_diffuse , & do_broadband , flux_up_loc , flux_dn_loc , flux_dir_loc ) class is ( ty_optical_props_nstr ) ! ! n-stream calculation ! ! not yet implemented so fail ! error_msg = 'sw_solver(...ty_optical_props_nstr...) not yet implemented' end select if ( len_trim ( error_msg ) > 0 ) then if ( len_trim ( atmos % get_name ()) > 0 ) & error_msg = trim ( atmos % get_name ()) // ': ' // trim ( error_msg ) end if ! ! Flux reduction (summarizing for output) ! select type ( fluxes ) ! ! Tidy up memory for broadband fluxes ! type is ( ty_fluxes_broadband ) if ( associated ( fluxes % flux_net )) then !$acc                         parallel loop    collapse(2) copyin(fluxes) copyout(fluxes%flux_net) !$omp target teams distribute parallel do simd collapse(2) do ilev = 1 , nlay + 1 do icol = 1 , ncol fluxes % flux_net ( icol , ilev ) = flux_dn_loc ( icol , ilev ) - flux_up_loc ( icol , ilev ) end do end do end if class default ! ! ...or reduce spectral fluxes to desired output quantities ! error_msg = fluxes % reduce ( gpt_flux_up , gpt_flux_dn , atmos , atmos % top_is_at_1 (), gpt_flux_dir ) end select end if ! In case of an error we exit here !$acc        end data !$omp end target data !$acc        end data !$omp end target data !$acc        end data !$omp end target data !$acc        end data !$omp end target data !$acc        end data !$omp end target data ! ! Deallocate any memory allocated locally to pointer variables ! select type ( fluxes ) type is ( ty_fluxes_broadband ) !$acc        exit data copyout( flux_up_loc, flux_dn_loc, flux_dir_loc) !$omp target exit data map(from:flux_up_loc, flux_dn_loc, flux_dir_loc) if (. not . associated ( fluxes % flux_up )) deallocate ( flux_up_loc ) if (. not . associated ( fluxes % flux_dn )) deallocate ( flux_dn_loc ) if (. not . associated ( fluxes % flux_dn_dir )) deallocate ( flux_dir_loc ) class default deallocate ( gpt_flux_up , gpt_flux_dn , gpt_flux_dir ) end select if (. not . has_dif_bc ) then !$acc        exit data delete(     inc_flux_diffuse) !$omp target exit data map(release:inc_flux_diffuse) deallocate ( inc_flux_diffuse ) end if end function rte_sw_mu0_full !-------------------------------------------------------------------------------------------------------------------- ! ! Expand from band to g-point dimension, transpose dimensions (nband, ncol) -> (ncol,ngpt) ! subroutine expand_and_transpose ( ops , arr_in , arr_out ) class ( ty_optical_props ), intent ( in ) :: ops real ( wp ), dimension (:,:), intent ( in ) :: arr_in ! (nband, ncol) real ( wp ), dimension (:,:), intent ( out ) :: arr_out ! (ncol, igpt) ! ------------- integer :: ncol , nband , ngpt integer :: icol , iband , igpt integer , dimension ( 2 , ops % get_nband ()) :: limits ncol = size ( arr_in , 2 ) nband = ops % get_nband () ngpt = ops % get_ngpt () limits = ops % get_band_lims_gpoint () !$acc                         parallel loop    collapse(2) copyin(arr_in, limits) !$omp target teams distribute parallel do simd collapse(2) map(to:arr_in, limits) do iband = 1 , nband do icol = 1 , ncol do igpt = limits ( 1 , iband ), limits ( 2 , iband ) arr_out ( icol , igpt ) = arr_in ( iband , icol ) end do end do end do end subroutine expand_and_transpose end module mo_rte_sw","tags":"","loc":"sourcefile/mo_rte_sw.f90.html"},{"title":"mo_source_functions.F90 – RTE-Fortran","text":"This file depends on sourcefile~~mo_source_functions.f90~~EfferentGraph sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array_validation.f90 mo_rte_util_array_validation.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array_validation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_source_functions.f90~~AfferentGraph sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_source_functions Source Code mo_source_functions.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-  Atmospheric and Environmental Research, !    Regents of the University of Colorado, !    Trustees of Columbia University in the City of New York ! All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! !> Encapsulate source function arrays for longwave/lw/internal sources !    and shortwave/sw/external source. ! ! ------------------------------------------------------------------------------------------------- module mo_source_functions use mo_rte_kind , only : wp use mo_optical_props , only : ty_optical_props implicit none private ! ------------------------------------------------------------------------------------------------- ! !> Type representing Planck source functions in W/m&#94;2 !>   computed at layer center, at layer edges using !>   spectral mapping in each direction separately, and at the surface !> type , extends ( ty_optical_props ), public :: ty_source_func_lw real ( wp ), allocatable , dimension (:,:,:) :: lay_source !! Planck source at layer average temperature (ncol, nlay, ngpt) real ( wp ), allocatable , dimension (:,:,:) :: lev_source !! Planck source at layer edge (ncol, nlay+1, ngpt) real ( wp ), allocatable , dimension (:,: ) :: sfc_source !! Planck function at surface temperature real ( wp ), allocatable , dimension (:,: ) :: sfc_source_Jac !! surface source Jacobian contains generic , public :: alloc => alloc_lw , copy_and_alloc_lw procedure , private :: alloc_lw procedure , private :: copy_and_alloc_lw procedure , public :: is_allocated => is_allocated_lw procedure , public :: finalize => finalize_lw procedure , public :: get_subset => get_subset_range_lw procedure , public :: get_ncol => get_ncol_lw procedure , public :: get_nlay => get_nlay_lw ! validate? end type ty_source_func_lw ! ------------------------------------------------------------------------------------------------- ! ! Type for shortave sources: top-of-domain spectrally-resolved flux !   The type isn't used at this time, so it's declared as private. ! type , extends ( ty_optical_props ), private :: ty_source_func_sw real ( wp ), allocatable , dimension (:,: ) :: toa_source contains generic , public :: alloc => alloc_sw , copy_and_alloc_sw procedure , private :: alloc_sw procedure , private :: copy_and_alloc_sw procedure , public :: is_allocated => is_allocated_sw procedure , public :: finalize => finalize_sw procedure , public :: get_subset => get_subset_range_sw procedure , public :: get_ncol => get_ncol_sw ! validate? end type ty_source_func_sw ! ------------------------------------------------------------------------------------------------- contains ! ------------------------------------------------------------------------------------------ ! !  Routines for initialization, validity checking, finalization ! ! ------------------------------------------------------------------------------------------ ! ! Longwave ! ! ------------------------------------------------------------------------------------------ pure function is_allocated_lw ( this ) class ( ty_source_func_lw ), intent ( in ) :: this logical :: is_allocated_lw is_allocated_lw = this % is_initialized () . and . & allocated ( this % sfc_source ) end function is_allocated_lw ! -------------------------------------------------------------- function alloc_lw ( this , ncol , nlay ) result ( err_message ) class ( ty_source_func_lw ), intent ( inout ) :: this integer , intent ( in ) :: ncol , nlay character ( len = 128 ) :: err_message integer :: ngpt err_message = \"\" if (. not . this % is_initialized ()) & err_message = \"source_func_lw%alloc: not initialized so can't allocate\" if ( any ([ ncol , nlay ] <= 0 )) & err_message = \"source_func_lw%alloc: must provide positive extents for ncol, nlay\" if ( err_message /= \"\" ) return if ( allocated ( this % sfc_source )) deallocate ( this % sfc_source ) if ( allocated ( this % sfc_source_Jac )) deallocate ( this % sfc_source_Jac ) if ( allocated ( this % lay_source )) deallocate ( this % lay_source ) if ( allocated ( this % lev_source )) deallocate ( this % lev_source ) ngpt = this % get_ngpt () allocate ( this % sfc_source ( ncol , ngpt ), this % lay_source ( ncol , nlay , ngpt ), & this % lev_source ( ncol , nlay + 1 , ngpt ), this % sfc_source_Jac ( ncol , ngpt )) end function alloc_lw ! -------------------------------------------------------------- function copy_and_alloc_lw ( this , ncol , nlay , spectral_desc ) result ( err_message ) class ( ty_source_func_lw ), intent ( inout ) :: this integer , intent ( in ) :: ncol , nlay class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len = 128 ) :: err_message err_message = \"\" if (. not . spectral_desc % is_initialized ()) then err_message = \"source_func_lw%alloc: spectral_desc not initialized\" return end if call this % finalize () err_message = this % init ( spectral_desc ) if ( err_message /= \"\" ) return err_message = this % alloc ( ncol , nlay ) end function copy_and_alloc_lw ! ------------------------------------------------------------------------------------------ ! ! Shortwave ! ! ------------------------------------------------------------------------------------------ pure function is_allocated_sw ( this ) class ( ty_source_func_sw ), intent ( in ) :: this logical :: is_allocated_sw is_allocated_sw = this % ty_optical_props % is_initialized () . and . & allocated ( this % toa_source ) end function is_allocated_sw ! -------------------------------------------------------------- function alloc_sw ( this , ncol ) result ( err_message ) class ( ty_source_func_sw ), intent ( inout ) :: this integer , intent ( in ) :: ncol character ( len = 128 ) :: err_message err_message = \"\" if (. not . this % is_initialized ()) & err_message = \"source_func_sw%alloc: not initialized so can't allocate\" if ( ncol <= 0 ) & err_message = \"source_func_sw%alloc: must provide positive extents for ncol\" if ( err_message /= \"\" ) return if ( allocated ( this % toa_source )) deallocate ( this % toa_source ) allocate ( this % toa_source ( ncol , this % get_ngpt ())) end function alloc_sw ! -------------------------------------------------------------- function copy_and_alloc_sw ( this , ncol , spectral_desc ) result ( err_message ) class ( ty_source_func_sw ), intent ( inout ) :: this integer , intent ( in ) :: ncol class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len = 128 ) :: err_message err_message = \"\" if (. not . spectral_desc % is_initialized ()) then err_message = \"source_func_sw%alloc: spectral_desc not initialized\" return end if err_message = this % init ( spectral_desc ) if ( err_message /= \"\" ) return err_message = this % alloc ( ncol ) end function copy_and_alloc_sw ! ------------------------------------------------------------------------------------------ ! ! Finalization (memory deallocation) ! ! ------------------------------------------------------------------------------------------ subroutine finalize_lw ( this ) class ( ty_source_func_lw ), intent ( inout ) :: this if ( allocated ( this % lay_source )) deallocate ( this % lay_source ) if ( allocated ( this % lev_source )) deallocate ( this % lev_source ) if ( allocated ( this % sfc_source )) deallocate ( this % sfc_source ) if ( allocated ( this % sfc_source_Jac )) deallocate ( this % sfc_source_Jac ) call this % ty_optical_props % finalize () end subroutine finalize_lw ! -------------------------------------------------------------- subroutine finalize_sw ( this ) class ( ty_source_func_sw ), intent ( inout ) :: this if ( allocated ( this % toa_source )) deallocate ( this % toa_source ) call this % ty_optical_props % finalize () end subroutine finalize_sw ! ------------------------------------------------------------------------------------------ ! !  Routines for finding the problem size ! ! ------------------------------------------------------------------------------------------ pure function get_ncol_lw ( this ) class ( ty_source_func_lw ), intent ( in ) :: this integer :: get_ncol_lw if ( this % is_allocated ()) then get_ncol_lw = size ( this % lay_source , 1 ) else get_ncol_lw = 0 end if end function get_ncol_lw ! -------------------------------------------------------------- pure function get_nlay_lw ( this ) class ( ty_source_func_lw ), intent ( in ) :: this integer :: get_nlay_lw if ( this % is_allocated ()) then get_nlay_lw = size ( this % lay_source , 2 ) else get_nlay_lw = 0 end if end function get_nlay_lw ! -------------------------------------------------------------- pure function get_ncol_sw ( this ) class ( ty_source_func_sw ), intent ( in ) :: this integer :: get_ncol_sw if ( this % is_allocated ()) then get_ncol_sw = size ( this % toa_source , 1 ) else get_ncol_sw = 0 end if end function get_ncol_sw ! ------------------------------------------------------------------------------------------ ! !  Routines for subsetting ! ! ------------------------------------------------------------------------------------------ function get_subset_range_lw ( full , start , n , subset ) result ( err_message ) class ( ty_source_func_lw ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_source_func_lw ), intent ( inout ) :: subset character ( 128 ) :: err_message err_message = \"\" if (. not . full % is_allocated ()) then err_message = \"source_func_lw%subset: Asking for a subset of unallocated data\" return end if if ( start < 1 . or . start + n - 1 > full % get_ncol ()) & err_message = \"optical_props%subset: Asking for columns outside range\" if ( err_message /= \"\" ) return ! ! Could check to see if subset is correctly sized, has consistent spectral discretization ! if ( subset % is_allocated ()) call subset % finalize () err_message = subset % alloc ( n , full % get_nlay (), full ) if ( err_message /= \"\" ) return subset % sfc_source ( 1 : n , :) = full % sfc_source ( start : start + n - 1 , :) subset % sfc_source_Jac ( 1 : n , :) = full % sfc_source_Jac ( start : start + n - 1 , :) subset % lay_source ( 1 : n ,:,:) = full % lay_source ( start : start + n - 1 ,:,:) subset % lev_source ( 1 : n ,:,:) = full % lev_source ( start : start + n - 1 ,:,:) end function get_subset_range_lw ! ------------------------------------------------------------------------------------------ function get_subset_range_sw ( full , start , n , subset ) result ( err_message ) class ( ty_source_func_sw ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_source_func_sw ), intent ( inout ) :: subset character ( 128 ) :: err_message err_message = \"\" if (. not . full % is_allocated ()) then err_message = \"source_func_sw%subset: Asking for a subset of unallocated data\" return end if if ( start < 1 . or . start + n - 1 > full % get_ncol ()) & err_message = \"optical_props%subset: Asking for columns outside range\" if ( err_message /= \"\" ) return ! ! Could check to see if subset is correctly sized, has consistent spectral discretization ! if ( subset % is_allocated ()) call subset % finalize () ! Seems like I should be able to call \"alloc\" generically but the compilers are complaining err_message = subset % copy_and_alloc_sw ( n , full ) subset % toa_source ( 1 : n , :) = full % toa_source ( start : start + n - 1 , :) end function get_subset_range_sw end module mo_source_functions","tags":"","loc":"sourcefile/mo_source_functions.f90.html"},{"title":"mo_optical_props.F90 – RTE-Fortran","text":"This file depends on sourcefile~~mo_optical_props.f90~~EfferentGraph sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array_validation.f90 mo_rte_util_array_validation.F90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array_validation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_optical_props.f90~~AfferentGraph sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_source_functions.f90 mo_source_functions.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_source_functions.f90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_source_functions.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_optical_props Source Code mo_optical_props.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-  Atmospheric and Environmental Research, !    Regents of the University of Colorado, !    Trustees of Columbia University in the City of New York ! All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- !> !> ## Encapsulate optical properties defined on a spectral grid of N bands. !> !>   The bands are described by their limiting wavenumbers. They need not be contiguous or complete. !>   A band may contain more than one spectral sub-point (g-point) in which case a mapping must be supplied. !>   A name may be provided and will be prepended to error messages. !>   The base class (ty_optical_props) encapsulates only this spectral discretization and must be initialized !>      with the spectral information before use. !> !>   Optical properties may be represented as arrays with dimensions ncol, nlay, ngpt !>   (abstract class ty_optical_props_arry). !>   The type holds arrays depending on how much information is needed !>   There are three possibilites !> !> - ty_optical_props_1scl holds absorption optical depth tau, used in calculations accounting for extinction and emission !> - ty_optical_props_2str holds extincion optical depth tau, single-scattering albedo ssa, and !>        asymmetry parameter g. These fields are what's needed for two-stream calculations. !> - ty_optical_props_nstr holds extincion optical depth tau, single-scattering albedo ssa, and !>        phase function moments p with leading dimension nmom. These fields are what's needed for multi-stream calculations. !> !>   These classes must be allocated before use. Initialization and allocation can be combined. !>   The classes have a validate() function that checks all arrays for valid values (e.g. tau > 0.) !>   The vertical orientation can be specified via this%set_top_at_1() or obtained via this%top_at_1(). !> !> Optical properties can be delta-scaled (though this is currently implemented only for two-stream arrays) !> !> Optical properties can increment or \"add themselves to\" a set of properties represented with arrays !>   as long as both sets have the same underlying band structure. Properties defined by band !>   may be added to properties defined by g-point; the same value is assumed for all g-points with each band. !> !> Subsets of optical properties held as arrays may be extracted along the column dimension. !> ! Making the documentation below visible in ford, by replace ! with !>, messes up Markdown parsing above !@note !example of a note with links to other modules and variables ! ! 1. [[mo_rte_config(module):check_extents(variable)]] in module [[mo_rte_config]] !> !@endnote !> ------------------------------------------------------------------------------------------------- module mo_optical_props use mo_rte_kind , only : wp , wl use mo_rte_config , only : check_extents , check_values use mo_rte_util_array_validation , & only : any_vals_less_than , any_vals_outside , extents_are use mo_optical_props_kernels , only : & increment_1scalar_by_1scalar , increment_1scalar_by_2stream , increment_1scalar_by_nstream , & increment_2stream_by_1scalar , increment_2stream_by_2stream , increment_2stream_by_nstream , & increment_nstream_by_1scalar , increment_nstream_by_2stream , increment_nstream_by_nstream , & inc_1scalar_by_1scalar_bybnd , inc_1scalar_by_2stream_bybnd , inc_1scalar_by_nstream_bybnd , & inc_2stream_by_1scalar_bybnd , inc_2stream_by_2stream_bybnd , inc_2stream_by_nstream_bybnd , & inc_nstream_by_1scalar_bybnd , inc_nstream_by_2stream_bybnd , inc_nstream_by_nstream_bybnd , & delta_scale_2str_kernel , & extract_subset implicit none private integer , parameter , public :: name_len = 32 ! ------------------------------------------------------------------------------------------------- ! !> ### Base class for optical properties !>   Describes the spectral discretization including the wavenumber limits !>   of each band (spectral region) and the mapping between g-points and bands ! ! ------------------------------------------------------------------------------------------------- type , public :: ty_optical_props integer , dimension (:,:), allocatable , private :: band2gpt ! (begin g-point, end g-point) = band2gpt(2,band) integer , dimension (:), allocatable , private :: gpt2band ! band = gpt2band(g-point) real ( wp ), dimension (:,:), allocatable , private :: band_lims_wvn ! (upper and lower wavenumber by band) = band_lims_wvn(2,band) character ( len = name_len ), private :: name = \"\" contains generic , public :: init => init_base , init_base_from_copy procedure , private :: init_base procedure , private :: init_base_from_copy procedure , public :: is_initialized => is_initialized_base procedure , private :: is_initialized_base procedure , public :: finalize => finalize_base procedure , private :: finalize_base procedure , public :: get_nband procedure , public :: get_ngpt procedure , public :: get_gpoint_bands procedure , public :: convert_band2gpt procedure , public :: convert_gpt2band procedure , public :: get_band_lims_gpoint procedure , public :: get_band_lims_wavenumber procedure , public :: get_band_lims_wavelength procedure , public :: bands_are_equal procedure , public :: gpoints_are_equal procedure , public :: expand procedure , public :: set_name procedure , public :: get_name end type ty_optical_props !---------------------------------------------------------------------------------------- ! !>### Optical properties as arrays, normally dimensioned ncol, nlay, ngpt/nbnd !>   The abstract base class for arrays defines what procedures will be available ! ! ------------------------------------------------------------------------------------------------- type , extends ( ty_optical_props ), abstract , public :: ty_optical_props_arry real ( wp ), dimension (:,:,:), allocatable :: tau !! optical depth (ncol, nlay, ngpt) logical ( wl ), private :: top_at_1 ! No default - maybe uninitialized values will get caught? contains procedure , public :: get_ncol procedure , public :: get_nlay !> !> Increment another set of values !> procedure , public :: increment !> !> !> procedure , public :: top_is_at_1 procedure , public :: set_top_at_1 !> !> Deferred procedures -- each must be implemented in each child class with !>   arguments following the abstract interface (defined below) !> procedure ( validate_abstract ), deferred , public :: validate procedure ( delta_scale_abstract ), deferred , public :: delta_scale procedure ( subset_range_abstract ), deferred , public :: get_subset end type ty_optical_props_arry ! ! Interfaces for the methods to be implemented ! abstract interface !> !> Validation function looks only at internal data !> function validate_abstract ( this ) result ( err_message ) import ty_optical_props_arry class ( ty_optical_props_arry ), intent ( in ) :: this character ( len = 128 ) :: err_message end function validate_abstract !> !> Delta-scaling !> function delta_scale_abstract ( this , for ) result ( err_message ) import ty_optical_props_arry import wp class ( ty_optical_props_arry ), intent ( inout ) :: this real ( wp ), dimension (:,:,:), optional , & intent ( in ) :: for !> Forward scattering fraction; g**2 if not provided character ( len = 128 ) :: err_message end function delta_scale_abstract !> !> Subsetting -- currently there are only routines with start col and count !> function subset_range_abstract ( full , start , n , subset ) result ( err_message ) import ty_optical_props_arry class ( ty_optical_props_arry ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_optical_props_arry ), intent ( inout ) :: subset character ( 128 ) :: err_message end function subset_range_abstract end interface !>---------------------------------------------------------------------------------------- !> !>   ty_optical_props_arry represents optical properties as arrays with dimensions !>      column, height, spectral point !>  - Class 1-scalar only (extinction) optical depth !>  -  Class two-stream adds arrays for single scattering albedo ssa and !>     asymmetry parameter needed in two-stream methods !>  - Class n-stream adds arrays for single scattering albedo ssa and !>     phase function moments (index 1 = g) for use with discrete ordinate methods !> !> ------------------------------------------------------------------------------------------------- type , public , extends ( ty_optical_props_arry ) :: ty_optical_props_1scl contains procedure , public :: validate => validate_1scalar procedure , public :: get_subset => subset_1scl_range procedure , public :: delta_scale => delta_scale_1scl procedure , public :: finalize_1scl procedure , private :: alloc_only_1scl procedure , private :: init_and_alloc_1scl procedure , private :: copy_and_alloc_1scl generic , public :: alloc_1scl => alloc_only_1scl , init_and_alloc_1scl , copy_and_alloc_1scl end type ty_optical_props_1scl ! --- 2 stream ------------------------------------------------------------------------ type , public , extends ( ty_optical_props_arry ) :: ty_optical_props_2str real ( wp ), dimension (:,:,:), allocatable :: ssa !! single-scattering albedo (ncol, nlay, ngpt) real ( wp ), dimension (:,:,:), allocatable :: g !! asymmetry parameter (ncol, nlay, ngpt) contains procedure , public :: validate => validate_2stream procedure , public :: get_subset => subset_2str_range procedure , public :: delta_scale => delta_scale_2str procedure , public :: finalize_2str procedure , private :: alloc_only_2str procedure , private :: init_and_alloc_2str procedure , private :: copy_and_alloc_2str generic , public :: alloc_2str => alloc_only_2str , init_and_alloc_2str , copy_and_alloc_2str end type ty_optical_props_2str ! --- n stream ------------------------------------------------------------------------ type , public , extends ( ty_optical_props_arry ) :: ty_optical_props_nstr real ( wp ), dimension (:,:,:), allocatable :: ssa !! single-scattering albedo (ncol, nlay, ngpt) real ( wp ), dimension (:,:,:,:), allocatable :: p !! phase-function moments (nmom, ncol, nlay, ngpt) contains procedure , public :: validate => validate_nstream procedure , public :: get_subset => subset_nstr_range procedure , public :: delta_scale => delta_scale_nstr procedure , public :: get_nmom procedure , public :: finalize_nstr procedure , private :: alloc_only_nstr procedure , private :: init_and_alloc_nstr procedure , private :: copy_and_alloc_nstr generic , public :: alloc_nstr => alloc_only_nstr , init_and_alloc_nstr , copy_and_alloc_nstr end type ty_optical_props_nstr ! ------------------------------------------------------------------------------------------------- contains ! ------------------------------------------------------------------------------------------------- ! !  Routines for the base class: initialization, validity checking, finalization ! !> ------------------------------------------------------------------------------------------------- !> !> Base class: Initialization !>   Values are assumed to be defined in bands a mapping between bands and g-points is provided !> !> ------------------------------------------------------------------------------------------------- function init_base ( this , band_lims_wvn , band_lims_gpt , name ) result ( err_message ) class ( ty_optical_props ), intent ( inout ) :: this real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn integer , dimension (:,:), & optional , intent ( in ) :: band_lims_gpt character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message integer :: iband integer , dimension ( 2 , size ( band_lims_wvn , 2 )) :: band_lims_gpt_lcl ! ------------------------- ! ! Error checking -- are the arrays the size we expect, contain positive values? ! err_message = \"\" if ( size ( band_lims_wvn , 1 ) /= 2 ) & err_message = \"optical_props%init(): band_lims_wvn 1st dim should be 2\" if ( check_values ) then if ( any_vals_less_than ( band_lims_wvn , 0._wp ) ) & err_message = \"optical_props%init(): band_lims_wvn has values <  0., respectively\" end if if ( err_message /= \"\" ) return if ( present ( band_lims_gpt )) then if ( check_extents ) then if (. not . extents_are ( band_lims_gpt , 2 , size ( band_lims_wvn , 2 ))) & err_message = \"optical_props%init(): band_lims_gpt size inconsistent with band_lims_wvn\" end if if ( check_values ) then if ( any ( band_lims_gpt < 1 ) ) & err_message = \"optical_props%init(): band_lims_gpt has values < 1\" end if if ( err_message /= \"\" ) return band_lims_gpt_lcl (:,:) = band_lims_gpt (:,:) else ! ! Assume that values are defined by band, one g-point per band ! do iband = 1 , size ( band_lims_wvn , 2 ) band_lims_gpt_lcl ( 1 : 2 , iband ) = iband end do end if ! ! Assignment ! if ( allocated ( this % band2gpt )) deallocate ( this % band2gpt ) if ( allocated ( this % band_lims_wvn )) deallocate ( this % band_lims_wvn ) allocate ( this % band2gpt ( 2 , size ( band_lims_wvn , 2 )), & this % band_lims_wvn ( 2 , size ( band_lims_wvn , 2 ))) this % band2gpt = band_lims_gpt_lcl this % band_lims_wvn = band_lims_wvn if ( present ( name )) this % name = trim ( name ) ! ! Make a map between g-points and bands !   Efficient only when g-point indexes start at 1 and are contiguous. ! if ( allocated ( this % gpt2band )) deallocate ( this % gpt2band ) allocate ( this % gpt2band ( maxval ( band_lims_gpt_lcl ))) do iband = 1 , size ( band_lims_gpt_lcl , dim = 2 ) this % gpt2band ( band_lims_gpt_lcl ( 1 , iband ): band_lims_gpt_lcl ( 2 , iband )) = iband end do end function init_base !------------------------------------------------------------------------------------------------- function init_base_from_copy ( this , spectral_desc ) result ( err_message ) class ( ty_optical_props ), intent ( inout ) :: this class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len = 128 ) :: err_message if (. not . spectral_desc % is_initialized ()) then err_message = \"optical_props%init(): can't initialize based on un-initialized input\" return else err_message = this % init ( spectral_desc % get_band_lims_wavenumber (), & spectral_desc % get_band_lims_gpoint ()) end if end function init_base_from_copy !>------------------------------------------------------------------------------------------------- !> !> Base class: return true if initialized, false otherwise !> !> ------------------------------------------------------------------------------------------------- pure function is_initialized_base ( this ) class ( ty_optical_props ), intent ( in ) :: this logical :: is_initialized_base is_initialized_base = allocated ( this % band2gpt ) end function is_initialized_base !>------------------------------------------------------------------------------------------------- !> !> Base class: finalize (deallocate memory) !> !> ------------------------------------------------------------------------------------------------- subroutine finalize_base ( this ) class ( ty_optical_props ), intent ( inout ) :: this if ( allocated ( this % band2gpt )) deallocate ( this % band2gpt ) if ( allocated ( this % gpt2band )) deallocate ( this % gpt2band ) if ( allocated ( this % band_lims_wvn )) & deallocate ( this % band_lims_wvn ) this % name = \"\" end subroutine finalize_base ! ------------------------------------------------------------------------------------------ ! !  Routines for array classes: initialization, allocation, and finalization !    Initialization and allocation can be combined by supplying either ! !> ------------------------------------------------------------------------------------------ !> !> Straight allocation routines !> !> --- 1 scalar ------------------------------------------------------------------------ function alloc_only_1scl ( this , ncol , nlay ) result ( err_message ) class ( ty_optical_props_1scl ) :: this integer , intent ( in ) :: ncol , nlay character ( len = 128 ) :: err_message err_message = \"\" if (. not . this % is_initialized ()) then err_message = \"optical_props%alloc: spectral discretization hasn't been provided\" return end if if ( any ([ ncol , nlay ] <= 0 )) then err_message = \"optical_props%alloc: must provide positive extents for ncol, nlay\" else if ( allocated ( this % tau )) deallocate ( this % tau ) allocate ( this % tau ( ncol , nlay , this % get_ngpt ())) end if end function alloc_only_1scl !> --- 2 stream ------------------------------------------------------------------------ function alloc_only_2str ( this , ncol , nlay ) result ( err_message ) class ( ty_optical_props_2str ) :: this integer , intent ( in ) :: ncol , nlay character ( len = 128 ) :: err_message err_message = \"\" if (. not . this % is_initialized ()) & err_message = \"optical_props%alloc: spectral discretization hasn't been provided\" if ( any ([ ncol , nlay ] <= 0 )) & err_message = \"optical_props%alloc: must provide positive extents for ncol, nlay\" if ( err_message /= \"\" ) return if ( allocated ( this % tau )) deallocate ( this % tau ) allocate ( this % tau ( ncol , nlay , this % get_ngpt ())) if ( allocated ( this % ssa )) deallocate ( this % ssa ) if ( allocated ( this % g )) deallocate ( this % g ) allocate ( this % ssa ( ncol , nlay , this % get_ngpt ()), this % g ( ncol , nlay , this % get_ngpt ())) end function alloc_only_2str !> --- n stream ------------------------------------------------------------------------ function alloc_only_nstr ( this , nmom , ncol , nlay ) result ( err_message ) class ( ty_optical_props_nstr ) :: this integer , intent ( in ) :: nmom ! number of moments integer , intent ( in ) :: ncol , nlay character ( len = 128 ) :: err_message err_message = \"\" if (. not . this % is_initialized ()) & err_message = \"optical_props%alloc: spectral discretization hasn't been provided\" if ( any ([ ncol , nlay ] <= 0 )) & err_message = \"optical_props%alloc: must provide positive extents for ncol, nlay\" if ( err_message /= \"\" ) return if ( allocated ( this % tau )) deallocate ( this % tau ) allocate ( this % tau ( ncol , nlay , this % get_ngpt ())) if ( allocated ( this % ssa )) deallocate ( this % ssa ) if ( allocated ( this % p )) deallocate ( this % p ) allocate ( this % ssa ( ncol , nlay , this % get_ngpt ()), this % p ( nmom , ncol , nlay , this % get_ngpt ())) end function alloc_only_nstr ! ------------------------------------------------------------------------------------------ ! ! Combined allocation/initialization routines ! !> ------------------------------------------------------------------------------------------ !> !> Initialization by specifying band limits and possibly g-point/band mapping !> !> --------------------------------------------------------------------------- function init_and_alloc_1scl ( this , ncol , nlay , band_lims_wvn , band_lims_gpt , name ) result ( err_message ) class ( ty_optical_props_1scl ) :: this integer , intent ( in ) :: ncol , nlay real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn integer , dimension (:,:), & optional , intent ( in ) :: band_lims_gpt character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = this % ty_optical_props % init ( band_lims_wvn , & band_lims_gpt , name ) if ( err_message /= \"\" ) return err_message = this % alloc_1scl ( ncol , nlay ) end function init_and_alloc_1scl ! --------------------------------------------------------------------------- function init_and_alloc_2str ( this , ncol , nlay , band_lims_wvn , band_lims_gpt , name ) result ( err_message ) class ( ty_optical_props_2str ) :: this integer , intent ( in ) :: ncol , nlay real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn integer , dimension (:,:), & optional , intent ( in ) :: band_lims_gpt character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = this % ty_optical_props % init ( band_lims_wvn , & band_lims_gpt , name ) if ( err_message /= \"\" ) return err_message = this % alloc_2str ( ncol , nlay ) end function init_and_alloc_2str ! --------------------------------------------------------------------------- function init_and_alloc_nstr ( this , nmom , ncol , nlay , band_lims_wvn , band_lims_gpt , name ) result ( err_message ) class ( ty_optical_props_nstr ) :: this integer , intent ( in ) :: nmom , ncol , nlay real ( wp ), dimension (:,:), intent ( in ) :: band_lims_wvn integer , dimension (:,:), & optional , intent ( in ) :: band_lims_gpt character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = this % ty_optical_props % init ( band_lims_wvn , & band_lims_gpt , name ) if ( err_message /= \"\" ) return err_message = this % alloc_nstr ( nmom , ncol , nlay ) end function init_and_alloc_nstr !>------------------------------------------------------------------------------------------------- !> !> Initialization from an existing spectral discretization/ty_optical_props !> !>------------------------------------------------------------------------------------------------- function copy_and_alloc_1scl ( this , ncol , nlay , spectral_desc , name ) result ( err_message ) class ( ty_optical_props_1scl ) :: this integer , intent ( in ) :: ncol , nlay class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = \"\" if ( this % ty_optical_props % is_initialized ()) call this % ty_optical_props % finalize () err_message = this % ty_optical_props % init ( spectral_desc % get_band_lims_wavenumber (), & spectral_desc % get_band_lims_gpoint (), name ) if ( err_message /= \"\" ) return err_message = this % alloc_1scl ( ncol , nlay ) end function copy_and_alloc_1scl ! --------------------------------------------------------------------------- function copy_and_alloc_2str ( this , ncol , nlay , spectral_desc , name ) result ( err_message ) class ( ty_optical_props_2str ) :: this integer , intent ( in ) :: ncol , nlay class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = \"\" if ( this % ty_optical_props % is_initialized ()) call this % ty_optical_props % finalize () err_message = this % ty_optical_props % init ( spectral_desc % get_band_lims_wavenumber (), & spectral_desc % get_band_lims_gpoint (), name ) if ( err_message /= \"\" ) return err_message = this % alloc_2str ( ncol , nlay ) end function copy_and_alloc_2str ! --------------------------------------------------------------------------- function copy_and_alloc_nstr ( this , nmom , ncol , nlay , spectral_desc , name ) result ( err_message ) class ( ty_optical_props_nstr ) :: this integer , intent ( in ) :: nmom , ncol , nlay class ( ty_optical_props ), intent ( in ) :: spectral_desc character ( len =* ), optional , intent ( in ) :: name character ( len = 128 ) :: err_message err_message = \"\" if ( this % ty_optical_props % is_initialized ()) call this % ty_optical_props % finalize () err_message = this % ty_optical_props % init ( spectral_desc % get_band_lims_wavenumber (), & spectral_desc % get_band_lims_gpoint (), name ) if ( err_message /= \"\" ) return err_message = this % alloc_nstr ( nmom , ncol , nlay ) end function copy_and_alloc_nstr !> ------------------------------------------------------------------------------------------ !> !> Finalize routines !> !> ------------------------------------------------------------------------------------------ function finalize_1scl ( this ) result ( err_message ) class ( ty_optical_props_1scl ) :: this character ( len = 128 ) :: err_message if ( allocated ( this % tau )) deallocate ( this % tau ) err_message = \"\" end function finalize_1scl ! --------------------------------------------------------------------------- function finalize_2str ( this ) result ( err_message ) class ( ty_optical_props_2str ) :: this character ( len = 128 ) :: err_message if ( allocated ( this % tau )) deallocate ( this % tau ) if ( allocated ( this % ssa )) deallocate ( this % ssa ) if ( allocated ( this % g )) deallocate ( this % g ) err_message = \"\" end function finalize_2str ! --------------------------------------------------------------------------- function finalize_nstr ( this ) result ( err_message ) class ( ty_optical_props_nstr ) :: this character ( len = 128 ) :: err_message if ( allocated ( this % tau )) deallocate ( this % tau ) if ( allocated ( this % ssa )) deallocate ( this % ssa ) if ( allocated ( this % p )) deallocate ( this % p ) err_message = \"\" end function finalize_nstr ! ------------------------------------------------------------------------------------------ ! !  Routines for array classes: delta-scaling, validation (ensuring all values can be used ) ! !> ------------------------------------------------------------------------------------------ !> --- delta scaling !> ------------------------------------------------------------------------------------------ function delta_scale_1scl ( this , for ) result ( err_message ) class ( ty_optical_props_1scl ), intent ( inout ) :: this real ( wp ), dimension (:,:,:), optional , & intent ( in ) :: for character ( 128 ) :: err_message ! ! Nothing to do ! err_message = \"\" end function delta_scale_1scl ! ------------------------------------------------------------------------------------------ function delta_scale_2str ( this , for ) result ( err_message ) class ( ty_optical_props_2str ), intent ( inout ) :: this real ( wp ), dimension (:,:,:), optional , & intent ( in ) :: for !! Forward scattering fraction; g**2 if not provided character ( 128 ) :: err_message integer :: ncol , nlay , ngpt ! -------------------------------- ncol = this % get_ncol () nlay = this % get_nlay () ngpt = this % get_ngpt () err_message = \"\" if ( present ( for )) then if ( check_extents ) then if (. not . extents_are ( for , ncol , nlay , ngpt )) then err_message = \"delta_scale: dimension of 'for' don't match optical properties arrays\" return end if end if if ( check_values ) then if ( any_vals_outside ( for , 0._wp , 1._wp )) then err_message = \"delta_scale: values of 'for' out of bounds [0,1]\" return end if end if call delta_scale_2str_kernel ( ncol , nlay , ngpt , this % tau , this % ssa , this % g , for ) else call delta_scale_2str_kernel ( ncol , nlay , ngpt , this % tau , this % ssa , this % g ) end if end function delta_scale_2str ! ------------------------------------------------------------------------------------------ function delta_scale_nstr ( this , for ) result ( err_message ) class ( ty_optical_props_nstr ), intent ( inout ) :: this real ( wp ), dimension (:,:,:), optional , & intent ( in ) :: for character ( 128 ) :: err_message err_message = 'delta_scale_nstr: Not yet implemented' end function delta_scale_nstr !> ------------------------------------------------------------------------------------------ !> !> --- Validation !> !> ------------------------------------------------------------------------------------------ function validate_1scalar ( this ) result ( err_message ) class ( ty_optical_props_1scl ), intent ( in ) :: this character ( len = 128 ) :: err_message err_message = '' if (. not . allocated ( this % tau )) then err_message = \"validate: tau not allocated/initialized\" return end if if ( check_values ) then if ( any_vals_less_than ( this % tau , 0._wp )) & err_message = \"validate: tau values out of range\" end if if ( len_trim ( err_message ) > 0 . and . len_trim ( this % get_name ()) > 0 ) & err_message = trim ( this % get_name ()) // ': ' // trim ( err_message ) end function validate_1scalar ! ------------------------------------------------------------------------------------------ function validate_2stream ( this ) result ( err_message ) class ( ty_optical_props_2str ), intent ( in ) :: this character ( len = 128 ) :: err_message integer :: d1 , d2 , d3 err_message = '' ! ! Array allocation status, sizing ! if ( check_extents ) then if (. not . all ([ allocated ( this % tau ), allocated ( this % ssa ), allocated ( this % g )])) then err_message = \"validate: arrays not allocated/initialized\" return end if d1 = size ( this % tau , 1 ) d2 = size ( this % tau , 2 ) d3 = size ( this % tau , 3 ) if (. not . extents_are ( this % ssa , d1 , d2 , d3 ) . or . & . not . extents_are ( this % g , d1 , d2 , d3 )) & err_message = \"validate: arrays not sized consistently\" end if ! ! Valid values ! if ( check_values ) then if ( any_vals_less_than ( this % tau , 0._wp )) & err_message = \"validate: tau values out of range\" if ( any_vals_outside ( this % ssa , 0._wp , 1._wp )) & err_message = \"validate: ssa values out of range\" if ( any_vals_outside ( this % g , - 1._wp , 1._wp )) & err_message = \"validate: g values out of range\" end if if ( len_trim ( err_message ) > 0 . and . len_trim ( this % get_name ()) > 0 ) & err_message = trim ( this % get_name ()) // ': ' // trim ( err_message ) end function validate_2stream ! ------------------------------------------------------------------------------------------ function validate_nstream ( this ) result ( err_message ) class ( ty_optical_props_nstr ), intent ( in ) :: this character ( len = 128 ) :: err_message integer :: d1 , d2 , d3 , d4 err_message = '' ! ! Array allocation status, sizing ! if (. not . all ([ allocated ( this % tau ), allocated ( this % ssa ), allocated ( this % p )])) then err_message = \"validate: arrays not allocated/initialized\" return end if d1 = size ( this % tau , 1 ) d2 = size ( this % tau , 2 ) d3 = size ( this % tau , 3 ) d4 = size ( this % p , 1 ) if ( check_extents ) then if (. not . extents_are ( this % ssa , d1 , d2 , d3 ) . or . & . not . extents_are ( this % p , d4 , d1 , d2 , d3 )) & err_message = \"validate: arrays not sized consistently\" end if ! ! Valid values ! if ( check_values ) then if ( any_vals_less_than ( this % tau , 0._wp )) & err_message = \"validate: tau values out of range\" if ( any_vals_outside ( this % ssa , 0._wp , 1._wp )) & err_message = \"validate: ssa values out of range\" if ( any_vals_outside ( this % p ( 1 ,:,:,:), - 1._wp , 1._wp )) & err_message = \"validate: p(1,:,:,:)  = g values out of range\" end if if ( len_trim ( err_message ) > 0 . and . len_trim ( this % get_name ()) > 0 ) & err_message = trim ( this % get_name ()) // ': ' // trim ( err_message ) end function validate_nstream ! ------------------------------------------------------------------------------------------ ! !  Routines for array classes: subsetting of optical properties arrays along x (col) direction ! ! Allocate class, then arrays; copy. Could probably be more efficient if !   classes used pointers internally. ! ! This set takes start position and number as scalars ! ! ------------------------------------------------------------------------------------------ function subset_1scl_range ( full , start , n , subset ) result ( err_message ) class ( ty_optical_props_1scl ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_optical_props_arry ), intent ( inout ) :: subset character ( 128 ) :: err_message integer :: ncol , nlay , ngpt , nmom err_message = \"\" if (. not . full % is_initialized ()) then err_message = \"optical_props%subset: Asking for a subset of uninitialized data\" return end if ncol = full % get_ncol () nlay = full % get_nlay () ngpt = full % get_ngpt () if ( start < 1 . or . start + n - 1 > full % get_ncol ()) & err_message = \"optical_props%subset: Asking for columns outside range\" if ( err_message /= \"\" ) return if ( subset % is_initialized ()) call subset % finalize () err_message = subset % init ( full ) ! Seems like the deallocation statements should be needed under Fortran 2003 !   but Intel compiler doesn't run without them if ( allocated ( subset % tau )) deallocate ( subset % tau ) select type ( subset ) class is ( ty_optical_props_1scl ) err_message = subset % alloc_1scl ( n , nlay ) if ( err_message /= \"\" ) return class is ( ty_optical_props_2str ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % g )) deallocate ( subset % g ) err_message = subset % alloc_2str ( n , nlay ) if ( err_message /= \"\" ) return subset % ssa ( 1 : n ,:,:) = 0._wp subset % g ( 1 : n ,:,:) = 0._wp class is ( ty_optical_props_nstr ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % p )) then nmom = subset % get_nmom () deallocate ( subset % p ) else nmom = 1 end if err_message = subset % alloc_nstr ( nmom , n , nlay ) if ( err_message /= \"\" ) return subset % ssa ( 1 : n ,:,:) = 0._wp subset % p (:, 1 : n ,:,:) = 0._wp end select call extract_subset ( ncol , nlay , ngpt , full % tau , start , start + n - 1 , subset % tau ) call subset % set_top_at_1 ( full % top_is_at_1 ()) end function subset_1scl_range ! ------------------------------------------------------------------------------------------ function subset_2str_range ( full , start , n , subset ) result ( err_message ) class ( ty_optical_props_2str ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_optical_props_arry ), intent ( inout ) :: subset character ( 128 ) :: err_message integer :: ncol , nlay , ngpt , nmom err_message = \"\" if (. not . full % is_initialized ()) then err_message = \"optical_props%subset: Asking for a subset of uninitialized data\" return end if ncol = full % get_ncol () nlay = full % get_nlay () ngpt = full % get_ngpt () if ( start < 1 . or . start + n - 1 > full % get_ncol ()) & err_message = \"optical_props%subset: Asking for columns outside range\" if ( err_message /= \"\" ) return if ( subset % is_initialized ()) call subset % finalize () err_message = subset % init ( full ) select type ( subset ) class is ( ty_optical_props_1scl ) err_message = subset % alloc_1scl ( n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , full % ssa , start , start + n - 1 , subset % tau ) class is ( ty_optical_props_2str ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % g )) deallocate ( subset % g ) err_message = subset % alloc_2str ( n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , start , start + n - 1 , subset % tau ) call extract_subset ( ncol , nlay , ngpt , full % ssa , start , start + n - 1 , subset % ssa ) call extract_subset ( ncol , nlay , ngpt , full % g , start , start + n - 1 , subset % g ) class is ( ty_optical_props_nstr ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % p )) then nmom = subset % get_nmom () deallocate ( subset % p ) else nmom = 1 end if err_message = subset % alloc_nstr ( nmom , n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , start , start + n - 1 , subset % tau ) call extract_subset ( ncol , nlay , ngpt , full % ssa , start , start + n - 1 , subset % ssa ) subset % p ( 1 , 1 : n ,:,:) = full % g ( start : start + n - 1 ,:,:) subset % p ( 2 :,:, :,:) = 0._wp end select call subset % set_top_at_1 ( full % top_is_at_1 ()) end function subset_2str_range ! ------------------------------------------------------------------------------------------ function subset_nstr_range ( full , start , n , subset ) result ( err_message ) class ( ty_optical_props_nstr ), intent ( inout ) :: full integer , intent ( in ) :: start , n class ( ty_optical_props_arry ), intent ( inout ) :: subset character ( 128 ) :: err_message integer :: ncol , nlay , ngpt , nmom err_message = \"\" if (. not . full % is_initialized ()) then err_message = \"optical_props%subset: Asking for a subset of uninitialized data\" return end if ncol = full % get_ncol () nlay = full % get_nlay () ngpt = full % get_ngpt () if ( start < 1 . or . start + n - 1 > full % get_ncol ()) & err_message = \"optical_props%subset: Asking for columns outside range\" if ( err_message /= \"\" ) return if ( subset % is_initialized ()) call subset % finalize () err_message = subset % init ( full ) if ( allocated ( subset % tau )) deallocate ( subset % tau ) select type ( subset ) class is ( ty_optical_props_1scl ) err_message = subset % alloc_1scl ( n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , full % ssa , start , start + n - 1 , subset % tau ) class is ( ty_optical_props_2str ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % g )) deallocate ( subset % g ) err_message = subset % alloc_2str ( n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , start , start + n - 1 , subset % tau ) call extract_subset ( ncol , nlay , ngpt , full % ssa , start , start + n - 1 , subset % ssa ) subset % g ( 1 : n ,:,:) = full % p ( 1 , start : start + n - 1 ,:,:) class is ( ty_optical_props_nstr ) if ( allocated ( subset % ssa )) deallocate ( subset % ssa ) if ( allocated ( subset % p )) deallocate ( subset % p ) err_message = subset % alloc_nstr ( nmom , n , nlay ) if ( err_message /= \"\" ) return call extract_subset ( ncol , nlay , ngpt , full % tau , start , start + n - 1 , subset % tau ) call extract_subset ( ncol , nlay , ngpt , full % ssa , start , start + n - 1 , subset % ssa ) call extract_subset ( nmom , ncol , nlay , ngpt , full % p , start , start + n - 1 , subset % p ) end select call subset % set_top_at_1 ( full % top_is_at_1 ()) end function subset_nstr_range !> ------------------------------------------------------------------------------------------ !> !>  Routines for array classes: incrementing !>   a%increment(b) adds the values of a to b, changing b and leaving a untouched !> !> ----------------------------------------------------------------------------------------- function increment ( op_in , op_io ) result ( err_message ) class ( ty_optical_props_arry ), intent ( in ) :: op_in class ( ty_optical_props_arry ), intent ( inout ) :: op_io character ( 128 ) :: err_message ! ----- integer :: ncol , nlay , ngpt ! ----- err_message = \"\" if (. not . op_in % is_initialized ()) & err_message = \"ty_optical_props%increment: Incrementing optical properties aren't initialized\" if (. not . op_in % is_initialized ()) & err_message = \"ty_optical_props%increment: optical properties to be incremented aren't initialized\" if ( err_message /= \"\" ) return ncol = op_io % get_ncol () nlay = op_io % get_nlay () ngpt = op_io % get_ngpt () if (. not . op_in % bands_are_equal ( op_io )) & err_message = \"ty_optical_props%increment: optical properties objects have different band structures\" if (. not . all ([ op_in % get_ncol (), op_in % get_nlay ()] == [ ncol , nlay ])) & err_message = \"ty_optical_props%increment: optical properties objects have different ncol and/or nlay\" if ( err_message /= \"\" ) return if ( op_in % gpoints_are_equal ( op_io )) then ! ! Increment by gpoint !   (or by band if both op_in and op_io are defined that way) ! select type ( op_io ) class is ( ty_optical_props_1scl ) select type ( op_in ) class is ( ty_optical_props_1scl ) call increment_1scalar_by_1scalar ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau ) class is ( ty_optical_props_2str ) call increment_1scalar_by_2stream ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau , op_in % ssa ) class is ( ty_optical_props_nstr ) call increment_1scalar_by_nstream ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau , op_in % ssa ) end select class is ( ty_optical_props_2str ) select type ( op_in ) class is ( ty_optical_props_1scl ) call increment_2stream_by_1scalar ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa ,& op_in % tau ) class is ( ty_optical_props_2str ) call increment_2stream_by_2stream ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa , op_io % g , & op_in % tau , op_in % ssa , op_in % g ) class is ( ty_optical_props_nstr ) call increment_2stream_by_nstream ( ncol , nlay , ngpt , op_in % get_nmom (), & op_io % tau , op_io % ssa , op_io % g , & op_in % tau , op_in % ssa , op_in % p ) end select class is ( ty_optical_props_nstr ) select type ( op_in ) class is ( ty_optical_props_1scl ) call increment_nstream_by_1scalar ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa , & op_in % tau ) class is ( ty_optical_props_2str ) call increment_nstream_by_2stream ( ncol , nlay , ngpt , op_io % get_nmom (), & op_io % tau , op_io % ssa , op_io % p , & op_in % tau , op_in % ssa , op_in % g ) class is ( ty_optical_props_nstr ) call increment_nstream_by_nstream ( ncol , nlay , ngpt , op_io % get_nmom (), op_in % get_nmom (), & op_io % tau , op_io % ssa , op_io % p , & op_in % tau , op_in % ssa , op_in % p ) end select end select else ! ! Values defined by-band will have ngpt() = nband() ! We can use values by band in op_in to increment op_io !   Anything else is an error ! if ( op_in % get_ngpt () /= op_io % get_nband ()) then err_message = \"ty_optical_props%increment: optical properties objects have incompatible g-point structures\" return end if ! ! Increment by band ! select type ( op_io ) class is ( ty_optical_props_1scl ) select type ( op_in ) class is ( ty_optical_props_1scl ) call inc_1scalar_by_1scalar_bybnd ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_2str ) call inc_1scalar_by_2stream_bybnd ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau , op_in % ssa , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_nstr ) call inc_1scalar_by_nstream_bybnd ( ncol , nlay , ngpt , & op_io % tau , & op_in % tau , op_in % ssa , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) end select class is ( ty_optical_props_2str ) select type ( op_in ) class is ( ty_optical_props_1scl ) call inc_2stream_by_1scalar_bybnd ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa , & op_in % tau , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_2str ) call inc_2stream_by_2stream_bybnd ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa , op_io % g , & op_in % tau , op_in % ssa , op_in % g , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_nstr ) call inc_2stream_by_nstream_bybnd ( ncol , nlay , ngpt , op_in % get_nmom (), & op_io % tau , op_io % ssa , op_io % g , & op_in % tau , op_in % ssa , op_in % p , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) end select class is ( ty_optical_props_nstr ) select type ( op_in ) class is ( ty_optical_props_1scl ) call inc_nstream_by_1scalar_bybnd ( ncol , nlay , ngpt , & op_io % tau , op_io % ssa , & op_in % tau , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_2str ) call inc_nstream_by_2stream_bybnd ( ncol , nlay , ngpt , op_io % get_nmom (), & op_io % tau , op_io % ssa , op_io % p , & op_in % tau , op_in % ssa , op_in % g , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) class is ( ty_optical_props_nstr ) call inc_nstream_by_nstream_bybnd ( ncol , nlay , ngpt , op_io % get_nmom (), op_in % get_nmom (), & op_io % tau , op_io % ssa , op_io % p , & op_in % tau , op_in % ssa , op_in % p , & op_io % get_nband (), op_io % get_band_lims_gpoint ()) end select end select end if end function increment !> ----------------------------------------------------------------------------------------------- !> !>  Routines for array classes: problem sizes !> !> ----------------------------------------------------------------------------------------------- pure function get_arry_extent ( this , dim ) class ( ty_optical_props_arry ), intent ( in ) :: this integer , intent ( in ) :: dim integer :: get_arry_extent if ( allocated ( this % tau )) then get_arry_extent = size ( this % tau , dim ) else get_arry_extent = 0 end if end function get_arry_extent ! ------------------------------------------------------------------------------------------ pure function get_ncol ( this ) class ( ty_optical_props_arry ), intent ( in ) :: this integer :: get_ncol get_ncol = get_arry_extent ( this , 1 ) end function get_ncol ! ------------------------------------------------------------------------------------------ pure function get_nlay ( this ) class ( ty_optical_props_arry ), intent ( in ) :: this integer :: get_nlay get_nlay = get_arry_extent ( this , 2 ) end function get_nlay ! ------------------------------------------------------------------------------------------ pure function get_nmom ( this ) class ( ty_optical_props_nstr ), intent ( in ) :: this integer :: get_nmom if ( allocated ( this % p )) then get_nmom = size ( this % p , 1 ) else get_nmom = 0 end if end function get_nmom !> ----------------------------------------------------------------------------------------------- !> !>  Routines for array classes: vertical orientation !> ! ------------------------------------------------------------------------------------------ pure function top_is_at_1 ( this ) ! ! Vertical orientation - .true. if array index 1 is top of atmosphere ! class ( ty_optical_props_arry ), intent ( in ) :: this logical :: top_is_at_1 top_is_at_1 = this % top_at_1 end function top_is_at_1 ! ------------------------------------------------------------------------------------------ subroutine set_top_at_1 ( this , top_at_1 ) ! !> Set vertical orientation of class - .true. if array index 1 is top of atmosphere ! class ( ty_optical_props_arry ), intent ( inout ) :: this logical , intent ( in ) :: top_at_1 this % top_at_1 = top_at_1 end subroutine set_top_at_1 ! ----------------------------------------------------------------------------------------------- ! !  Routines for base class: spectral discretization ! !> ----------------------------------------------------------------------------------------------- !> !> Number of bands !> pure function get_nband ( this ) class ( ty_optical_props ), intent ( in ) :: this integer :: get_nband if ( this % is_initialized ()) then get_nband = size ( this % band2gpt , dim = 2 ) else get_nband = 0 end if end function get_nband !> ----------------------------------------------------------------------------------------------- !> !> Number of g-points !> pure function get_ngpt ( this ) class ( ty_optical_props ), intent ( in ) :: this integer :: get_ngpt if ( this % is_initialized ()) then get_ngpt = maxval ( this % band2gpt ) else get_ngpt = 0 end if end function get_ngpt !>-------------------------------------------------------------------------------------------------------------------- !> !> The first and last g-point of all bands at once !> dimension (2, nbands) !> pure function get_band_lims_gpoint ( this ) class ( ty_optical_props ), intent ( in ) :: this integer , dimension ( size ( this % band2gpt , dim = 1 ), size ( this % band2gpt , dim = 2 )) & :: get_band_lims_gpoint get_band_lims_gpoint = this % band2gpt end function get_band_lims_gpoint !>-------------------------------------------------------------------------------------------------------------------- !> !> First and last g-point of a specific band !> pure function convert_band2gpt ( this , band ) class ( ty_optical_props ), intent ( in ) :: this integer , intent ( in ) :: band integer , dimension ( 2 ) :: convert_band2gpt if ( this % is_initialized ()) then convert_band2gpt (:) = this % band2gpt (:, band ) else convert_band2gpt (:) = 0 end if end function convert_band2gpt !>-------------------------------------------------------------------------------------------------------------------- !> !> Lower and upper wavenumber of all bands !> (upper and lower wavenumber by band) = band_lims_wvn(2,band) !> pure function get_band_lims_wavenumber ( this ) class ( ty_optical_props ), intent ( in ) :: this real ( wp ), dimension ( size ( this % band_lims_wvn , 1 ), size ( this % band_lims_wvn , 2 )) & :: get_band_lims_wavenumber if ( this % is_initialized ()) then get_band_lims_wavenumber (:,:) = this % band_lims_wvn (:,:) else get_band_lims_wavenumber (:,:) = 0._wp end if end function get_band_lims_wavenumber !>-------------------------------------------------------------------------------------------------------------------- !> !> Lower and upper wavelength of all bands !> pure function get_band_lims_wavelength ( this ) class ( ty_optical_props ), intent ( in ) :: this real ( wp ), dimension ( size ( this % band_lims_wvn , 1 ), size ( this % band_lims_wvn , 2 )) & :: get_band_lims_wavelength if ( this % is_initialized ()) then get_band_lims_wavelength (:,:) = 1._wp / this % band_lims_wvn (:,:) else get_band_lims_wavelength (:,:) = 0._wp end if end function get_band_lims_wavelength !>-------------------------------------------------------------------------------------------------------------------- !> Bands for all the g-points at once !> dimension (ngpt) !> pure function get_gpoint_bands ( this ) class ( ty_optical_props ), intent ( in ) :: this integer , dimension ( size ( this % gpt2band , dim = 1 )) & :: get_gpoint_bands if ( this % is_initialized ()) then get_gpoint_bands (:) = this % gpt2band (:) else get_gpoint_bands (:) = 0 end if end function get_gpoint_bands !>-------------------------------------------------------------------------------------------------------------------- !> !> Band associated with a specific g-point !> pure function convert_gpt2band ( this , gpt ) class ( ty_optical_props ), intent ( in ) :: this integer , intent ( in ) :: gpt integer :: convert_gpt2band if ( this % is_initialized ()) then convert_gpt2band = this % gpt2band ( gpt ) else convert_gpt2band = 0 end if end function convert_gpt2band !>-------------------------------------------------------------------------------------------------------------------- !> !> Expand an array of dimension arr_in(nband) to dimension arr_out(ngpt) !> pure function expand ( this , arr_in ) result ( arr_out ) class ( ty_optical_props ), intent ( in ) :: this real ( wp ), dimension (:), intent ( in ) :: arr_in ! (nband) real ( wp ), dimension ( size ( this % gpt2band )) :: arr_out integer :: iband do iband = 1 , this % get_nband () arr_out ( this % band2gpt ( 1 , iband ): this % band2gpt ( 2 , iband )) = arr_in ( iband ) end do end function expand !>-------------------------------------------------------------------------------------------------------------------- !> !> Are the bands of two objects the same? (same number, same wavelength limits) !> pure function bands_are_equal ( this , that ) class ( ty_optical_props ), intent ( in ) :: this , that logical :: bands_are_equal bands_are_equal = this % get_nband () == that % get_nband () . and . & this % get_nband () > 0 if (. not . bands_are_equal ) return bands_are_equal = & all ( abs ( this % get_band_lims_wavenumber () - that % get_band_lims_wavenumber ()) < & 5._wp * spacing ( this % get_band_lims_wavenumber ())) end function bands_are_equal !>-------------------------------------------------------------------------------------------------------------------- !> !> Is the g-point structure of two objects the same? !>   (same bands, same number of g-points, same mapping between bands and g-points) !> pure function gpoints_are_equal ( this , that ) class ( ty_optical_props ), intent ( in ) :: this , that logical :: gpoints_are_equal gpoints_are_equal = this % bands_are_equal ( that ) . and . & this % get_ngpt () == that % get_ngpt () if (. not . gpoints_are_equal ) return gpoints_are_equal = & all ( this % get_gpoint_bands () == that % get_gpoint_bands ()) end function gpoints_are_equal !> ----------------------------------------------------------------------------------------------- !> !> --- Setting/getting the name !> !> ----------------------------------------------------------------------------------------------- subroutine set_name ( this , name ) class ( ty_optical_props ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: name this % name = trim ( name ) end subroutine set_name ! -------------------------------------------------------- function get_name ( this ) class ( ty_optical_props ), intent ( in ) :: this character ( len = name_len ) :: get_name get_name = trim ( this % name ) end function get_name ! ------------------------------------------------------------------------------------------ end module mo_optical_props","tags":"","loc":"sourcefile/mo_optical_props.f90.html"},{"title":"mo_fluxes.F90 – RTE-Fortran","text":"This file depends on sourcefile~~mo_fluxes.f90~~EfferentGraph sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_config.f90 mo_rte_config.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_rte_util_array_validation.f90 mo_rte_util_array_validation.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_rte_util_array_validation.f90 sourcefile~mo_optical_props.f90 mo_optical_props.F90 sourcefile~mo_fluxes.f90->sourcefile~mo_optical_props.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_config.f90 sourcefile~mo_optical_props.f90->sourcefile~mo_rte_util_array_validation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mo_fluxes.f90~~AfferentGraph sourcefile~mo_fluxes.f90 mo_fluxes.F90 sourcefile~mo_rte_lw.f90 mo_rte_lw.F90 sourcefile~mo_rte_lw.f90->sourcefile~mo_fluxes.f90 sourcefile~mo_rte_sw.f90 mo_rte_sw.F90 sourcefile~mo_rte_sw.f90->sourcefile~mo_fluxes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mo_fluxes Source Code mo_fluxes.F90 Source Code ! This code is part of Radiative Transfer for Energetics (RTE) ! ! Contacts: Robert Pincus and Eli Mlawer ! email:  rrtmgp@aer.com ! ! Copyright 2015-  Atmospheric and Environmental Research and ! Regents of the University of Colorado.  All right reserved. ! ! Use and duplication is permitted under the terms of the !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause ! ------------------------------------------------------------------------------------------------- ! !> ## Compute output quantities from spectrally-resolved flux profiles !> !>    This module contains an abstract class and a broadband implmentation that sums over all spectral points !>    The abstract base class defines the routines that extenstions must implement: `reduce()` and `are_desired()` !>    The intent is for users to extend it as required, using mo_flxues_broadband as an example ! ! ------------------------------------------------------------------------------------------------- module mo_fluxes use mo_rte_kind , only : wp use mo_rte_config , only : check_extents use mo_rte_util_array_validation , only : extents_are use mo_optical_props , only : ty_optical_props use mo_fluxes_broadband_kernels , & only : sum_broadband , net_broadband implicit none private ! ----------------------------------------------------------------------------------------------- ! !> Abstract base class: !>   `reduce()` function accepts spectral flux profiles, computes desired outputs !>   `are_desired()` returns a logical ! ! ----------------------------------------------------------------------------------------------- type , abstract , public :: ty_fluxes contains procedure ( reduce_abstract ), deferred , public :: reduce procedure ( are_desired_abstract ), deferred , public :: are_desired end type ty_fluxes ! ----------------------------------------------------------------------------------------------- ! !> Class implementing broadband integration for the complete flux profile. !>   Data components are pointers so results can be written directly into memory ! ! ----------------------------------------------------------------------------------------------- type , extends ( ty_fluxes ), public :: ty_fluxes_broadband real ( wp ), dimension (:,:), pointer :: flux_up => NULL (), flux_dn => NULL () real ( wp ), dimension (:,:), pointer :: flux_net => NULL () ! Net (down - up) real ( wp ), dimension (:,:), pointer :: flux_dn_dir => NULL () ! Direct flux down contains procedure , public :: reduce => reduce_broadband procedure , public :: are_desired => are_desired_broadband end type ty_fluxes_broadband ! ----------------------------------------------------------------------------------------------- ! ----------------------------------------------------------------------------------------------- ! ! Abstract interfaces: any implemntation has to provide routines with these interfaces ! abstract interface ! ------------------- ! !> This routine takes the fully resolved calculation (detailed in spectral and vertical dimensions) and !>   computes desired outputs. Output values will normally be data components of the derived type. ! function reduce_abstract ( this , gpt_flux_up , gpt_flux_dn , spectral_disc , top_at_1 , gpt_flux_dn_dir ) result ( error_msg ) import ty_fluxes , ty_optical_props import wp class ( ty_fluxes ), intent ( inout ) :: this real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_up ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_dn ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) class ( ty_optical_props ), intent ( in ) :: spectral_disc !< derived type with spectral information logical , intent ( in ) :: top_at_1 real ( kind = wp ), dimension (:,:,:), optional , & intent ( in ) :: gpt_flux_dn_dir ! Direct flux down character ( len = 128 ) :: error_msg end function reduce_abstract ! ------------------- ! ! This routine determines if the reduction should proceed - it's useful in ensuring !   that space has been allocated for the results, for example. ! function are_desired_abstract ( this ) import ty_fluxes class ( ty_fluxes ), intent ( in ) :: this logical :: are_desired_abstract end function are_desired_abstract ! ---------------------- end interface contains ! -------------------------------------------------------------------------------------- ! !> Broadband fluxes -- simply sum over the spectral dimension and report the whole profile ! ! -------------------------------------------------------------------------------------- function reduce_broadband ( this , gpt_flux_up , gpt_flux_dn , spectral_disc , top_at_1 , gpt_flux_dn_dir ) result ( error_msg ) class ( ty_fluxes_broadband ), intent ( inout ) :: this real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_up ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) real ( kind = wp ), dimension (:,:,:), intent ( in ) :: gpt_flux_dn ! Fluxes by gpoint [W/m2](ncol, nlay+1, ngpt) class ( ty_optical_props ), intent ( in ) :: spectral_disc !< derived type with spectral information logical , intent ( in ) :: top_at_1 real ( kind = wp ), dimension (:,:,:), optional , & intent ( in ) :: gpt_flux_dn_dir ! Direct flux down character ( len = 128 ) :: error_msg ! ------ integer :: ncol , nlev , ngpt ! ------ ncol = size ( gpt_flux_up , DIM = 1 ) nlev = size ( gpt_flux_up , DIM = 2 ) ngpt = size ( gpt_flux_up , DIM = 3 ) error_msg = \"\" if ( check_extents ) then ! ! Check array sizes !  Input arrays ! if (. not . extents_are ( gpt_flux_dn , ncol , nlev , ngpt )) & error_msg = \"reduce: gpt_flux_dn array incorrectly sized\" if ( present ( gpt_flux_dn_dir )) then if (. not . extents_are ( gpt_flux_dn_dir , ncol , nlev , ngpt )) & error_msg = \"reduce: gpt_flux_dn_dir array incorrectly sized\" end if ! ! Output arrays ! if ( associated ( this % flux_up )) then if (. not . extents_are ( this % flux_up , ncol , nlev )) & error_msg = 'reduce: flux_up array incorrectly sized' end if if ( associated ( this % flux_dn )) then if (. not . extents_are ( this % flux_dn , ncol , nlev )) & error_msg = 'reduce: flux_dn array incorrectly sized' end if if ( associated ( this % flux_net )) then if (. not . extents_are ( this % flux_net , ncol , nlev )) & error_msg = 'reduce: flux_net array incorrectly sized' end if if ( associated ( this % flux_dn_dir )) then if (. not . extents_are ( this % flux_dn_dir , ncol , nlev )) & error_msg = 'reduce: flux_dn_dir array incorrectly sized' end if if ( error_msg /= \"\" ) return end if ! ! Self-consistency -- shouldn't be asking for direct beam flux if it isn't supplied ! if ( associated ( this % flux_dn_dir ) . and . . not . present ( gpt_flux_dn_dir )) then error_msg = \"reduce: requesting direct downward flux but this hasn't been supplied\" return end if ! ! Broadband fluxes - call the kernels ! if ( associated ( this % flux_up )) & call sum_broadband ( ncol , nlev , ngpt , gpt_flux_up , this % flux_up ) if ( associated ( this % flux_dn )) & call sum_broadband ( ncol , nlev , ngpt , gpt_flux_dn , this % flux_dn ) if ( associated ( this % flux_dn_dir )) & call sum_broadband ( ncol , nlev , ngpt , gpt_flux_dn_dir , this % flux_dn_dir ) if ( associated ( this % flux_net )) then ! !  Reuse down and up results if possible ! if ( associated ( this % flux_dn ) . and . associated ( this % flux_up )) then call net_broadband ( ncol , nlev , this % flux_dn , this % flux_up , this % flux_net ) else call net_broadband ( ncol , nlev , ngpt , gpt_flux_dn , gpt_flux_up , this % flux_net ) end if end if end function reduce_broadband ! -------------------------------------------------------------------------------------- ! !> Are any fluxes desired from this set of g-point fluxes? We can tell because memory will !>   be allocated for output ! ! -------------------------------------------------------------------------------------- function are_desired_broadband ( this ) class ( ty_fluxes_broadband ), intent ( in ) :: this logical :: are_desired_broadband are_desired_broadband = any ( [ associated ( this % flux_up ), & associated ( this % flux_dn ), & associated ( this % flux_dn_dir ), & associated ( this % flux_net )] ) end function are_desired_broadband ! -------------------------------------------------------------------------------------- end module mo_fluxes","tags":"","loc":"sourcefile/mo_fluxes.f90.html"}]}